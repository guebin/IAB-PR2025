[
  {
    "objectID": "content/05wk-2.html#str-고급",
    "href": "content/05wk-2.html#str-고급",
    "title": "05wk-2: [Python] – str, list // 숙제",
    "section": "1. str – 고급",
    "text": "1. str – 고급\n\nA. fstring\n- 예제1\n\na=1\nb=2\nprint(f'a+b = {a+b}')\n\na+b = 3\n\n\n- 예제2\n\na=2\nb=3.141592\nprint(f'a*b = {a*b:.4f}')\n\na*b = 6.2832\n\n\n- 예제3\n\na=3.141592\nprint(f'2a = {2*a:.2f}\\t3a = {3*a:.2f}')\n\n2a = 6.28   3a = 9.42\n\n\n\n\nB. string과 for문\n- 예제1\n\nfor s in 'jbnu':\n    print(2*s)\n\njj\nbb\nnn\nuu\n\n\n- 예제2\n\nfor s in 'jbnu':\n    print(s.upper())\n\nJ\nB\nN\nU\n\n\n\n\nC. in 연산자\n\ns = 'jbnu'\n\n\n'b' in s\n\nTrue\n\n\n\n'c' in s\n\nFalse\n\n\n\n'jb' in s\n\nTrue\n\n\n\n'jn' in s\n\nFalse\n\n\n\n\nD. split과 join\n- 예제1\n\n'2021.08.14'.split('.')\n\n['2021', '08', '14']\n\n\n- 예제2\n\n'asdf'*2\n\n'asdfasdf'\n\n\n\n('asdf'*2).split('f')\n\n['asd', 'asd', '']\n\n\n- 예제3\n\n'-'.join('asdf')\n\n'a-s-d-f'\n\n\n- 예제4\n\n'-'.join(['a','s','d','f'])\n\n'a-s-d-f'"
  },
  {
    "objectID": "content/05wk-2.html#list",
    "href": "content/05wk-2.html#list",
    "title": "05wk-2: [Python] – str, list // 숙제",
    "section": "2. list",
    "text": "2. list\n\nA. 선언\n- 리스트의 선언\n\na = [1,2,3,4]\na\n\n[1, 2, 3, 4]\n\n\n- 비어있는 리스트의 선언\n\na= []\na\n\n[]\n\n\n\na= list()\na\n\n[]\n\n\n\n\nB. 연산\n- 더하기연산\n\n[1,2,3] + [-3,4,5]\n\n[1, 2, 3, -3, 4, 5]\n\n\n\n우리의 예상과 다른 결과가 나옴 \\(\\to\\) 파이썬은 R처럼 자체적으로 좋은 계산기능을 내장하고 있지 않음.\n\n- 브로드캐스팅과 같이 R에서는 당연히 가능했던 기능을 사용할 수 없음.\n\n[1,2,3,4,5] + 1\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[284], line 1\n----&gt; 1 [1,2,3,4,5] + 1\n\nTypeError: can only concatenate list (not \"int\") to list\n\n\n\n- 뺄셈은 정의되지 않음\n\na= [1,2,1,2]\na-[1,2]\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[291], line 2\n      1 a= [1,2,1,2]\n----&gt; 2 a-[1,2]\n\nTypeError: unsupported operand type(s) for -: 'list' and 'list'\n\n\n\n- 곱하기는 정의가능\n\n[1,2]*3\n\n[1, 2, 1, 2, 1, 2]\n\n\n- 나눗셈은 정의되지 않음\n\n[1,2,1,2,1,2] /3\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[294], line 1\n----&gt; 1 [1,2,1,2,1,2] /3\n\nTypeError: unsupported operand type(s) for /: 'list' and 'int'\n\n\n\n- 더하기와 곱하기는 원소의 추가와 반복추가를 의미하지만 그렇다고 해서 뺄셈과 나눗셈이 원소의 삭제를 의미하는것은 아님\n- 더하기와 곱하기가 원소의 추가와 반복추가를 의미하여 편리할때도 있긴하지만, 우리는 산술적인 +, * 를 원하는 경우도 있다. 이럴 경우는 어떻게 할 수 있을까?\n(예제)\n\na=[1,2]\nb=[3,4]\n\na+b = [4,6] 이 되도록 하려면?\n(풀이1)\n\n[a[0]+b[0], a[1]+b[1]]\n\n[4, 6]\n\n\n풀이가 가능한 이유? a,b는 리스트이지만 a[0], a[1], b[0], b[1] 은 각각 인트형임. 인트형은 + 연산이 가능했음.\n(풀이2)\n\nimport numpy \n\n\na=[1,2]\nb=[3,4]\n\n\naa = numpy.array(a)\nbb = numpy.array(b)\n\n\na\n\n[1, 2]\n\n\n\naa+bb\n\narray([4, 6])\n\n\n여러가지 연산 가능 (마치 R처럼 쓸 수 있음)\n\n2*aa\n\narray([2, 4])\n\n\n\n2*aa+1\n\narray([3, 5])\n\n\n\n2*aa+1+bb\n\narray([6, 9])\n\n\n(풀이3)\n\nimport numpy as np ## 설치가 되어있는 numpy라는 패키지를 쓰겠음. 그런데 numpy말고 np라는 이름으로 쓰겠음\n\n\nnp.array(a)\n\narray([1, 2])\n\n\n\nnp.array(a)+np.array(b)\n\narray([4, 6])\n\n\n\n\nC. 인덱싱\n- str형과 동일한 방식\n\na=[11,22,33,44,55]\n\n\na[-2:] # 끝의 2개의 원소를 뽑음 \n\n[44, 55]\n\n\n\n\nD. 콘테이너형 객체로서의 리스트\n- 리스트의 원소는 int, float 따위만 가능한 것이 아니다. (리스트는 컨테이너형 객체이므로)\n\nx = [True, False, True, 2]\nx\n\n[True, False, True, 2]\n\n\n\nlst = [1,3.14,True,'a',[1,2], \n       (1,2),{'name':'iu','age':27},{1,2,3}]\nlst\n\n[1, 3.14, True, 'a', [1, 2], (1, 2), {'name': 'iu', 'age': 27}, {1, 2, 3}]\n\n\n- str은 컨테이너형이 아니다.\n\n'asdf'\n\n'asdf'\n\n\n\nstr의 모든 원소는 문자임\n\n\n\nE. 가변객체\n- 리스트는 원소를 수정할 수 있다. (리스트는 가변객체이므로)\n\na = [11,22,33]\na\n\n[11, 22, 33]\n\n\n\na[0] = -77\n\n\na\n\n[-77, 22, 33]\n\n\n- 원소수정은 당연한 기능같은데 이것이 불가능한 경우도 있다.\n(가능한경우)\n\na=['g','u','e','b','i','n']\na\n\n['g', 'u', 'e', 'b', 'i', 'n']\n\n\n\na[0] = 'G'\n\n\na\n\n['G', 'u', 'e', 'b', 'i', 'n']\n\n\n(불가능한경우)\n\na='guebin'\na\n\n'guebin'\n\n\n\na[0]\n\n'g'\n\n\n\na[0]='G'\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[384], line 1\n----&gt; 1 a[0]='G'\n\nTypeError: 'str' object does not support item assignment\n\n\n\n만약에 억지로 바꾸고 싶다면?\n\nl = list(a)\nl[0] = 'G'\n''.join(l)\n\n'Guebin'\n\n\n\n\nF. 리스트의 원소 삭제\n(예제1) del을 이용한 원소삭제\n아래와 같이 문자로 된 리스트를 선언하자.\n\na = ['g','u','e','b','i','n']\na\n\n['g', 'u', 'e', 'b', 'i', 'n']\n\n\n사실 더 쉽게 선언할 수 있음\n\nlist('guebin')\n\n['g', 'u', 'e', 'b', 'i', 'n']\n\n\n첫번째 원소를 삭제하고 싶다면?\n\ndel a[0]\n\n\na\n\n['u', 'e', 'b', 'i', 'n']\n\n\n이 상태에서 다시 첫번째 원소를 삭제한다면?\n\ndel a[0]\n\n\na\n\n['e', 'b', 'i', 'n']\n\n\n(예제2) pop을 이용한 원소삭제\n\na=list('guebin')\na\n\n['g', 'u', 'e', 'b', 'i', 'n']\n\n\n\na.pop(0)\n\n'g'\n\n\n\na\n\n['u', 'e', 'b', 'i', 'n']\n\n\n\na.pop(0)\n\n'u'\n\n\n\na\n\n['e', 'b', 'i', 'n']\n\n\n(예제3) remove를 이용한 원소삭제\n\na=list('guebin')\na\n\n['g', 'u', 'e', 'b', 'i', 'n']\n\n\n\na.remove('b')\na\n\n['g', 'u', 'e', 'i', 'n']\n\n\n\n\nG. 리스트 원소 추가\n(예제) 비어있는 리스트를 만들고 원소 0,1,2를 차례로 추가하여 보자.\n(풀이1) + 연산이용\n\na=[]\na\n\n[]\n\n\n\na= a+[0]\na\n\n[0]\n\n\n\na= a+[1] # a = [0]+[1]\na\n\n[0, 1]\n\n\n\na= a+[2] # a = [0,1] + [2]\na\n\n[0, 1, 2]\n\n\n(풀이2) += 이용\n\na = []\na += [0]\na += [1] \na += [2] \na\n\n[0, 1, 2]\n\n\n\n반복되는 문자를 제거하고 연산의 순서를 바꾼다.\n\n(풀이3) 리스트 특수기능 .append()를 이용\n\na=[] \n\n\na.append(0)\na.append(1)\na.append(2)\na\n\n[0, 1, 2, 0, 1, 2]\n\n\n\n\nH. a+[4]와 a.append(4)의 차이점은?\n(관찰1)\n\na=[1,2,3]\na+[4] ## 리스트 a와 리스트 [4]의 연산결과를 알려줘 \n\n[1, 2, 3, 4]\n\n\n\na ## a는 그대로임. 변화없음 \n\n[1, 2, 3]\n\n\n(관찰2)\n\na=[1,2,3]\na.append(4)\n\n\na ## a자체가 변화함 \n\n[1, 2, 3, 4]\n\n\n비슷해보이지만 굉장히 미묘한 차이가 있음\na.append(4): a에 4를 append하라 \\(\\to\\) a가 변함\na+[4]: a와 [4]를 연산하라\n\n\nI. 리스트 특수기능\n(append)\n\na=[1,2,3,4]\na.append?\n\n\nSignature: a.append(object, /)\nDocstring: Append object to the end of the list.\nType:      builtin_function_or_method\n\n\n\n\na.append(5)\na\n\n[1, 2, 3, 4, 5]\n\n\n(clear)\n\na=[1,2,3,4]\na.clear?\n\n\nSignature: a.clear()\nDocstring: Remove all items from list.\nType:      builtin_function_or_method\n\n\n\n\na.clear()\na\n\n[]\n\n\n(copy)\n\na=[1,2,3,4]\na.copy?\n\n\nSignature: a.copy()\nDocstring: Return a shallow copy of the list.\nType:      builtin_function_or_method\n\n\n\n\nb=a.copy()\nb\n\n[1, 2, 3, 4]\n\n\n(count)\n\na=['a','a','b','b','b','c']\na.count?\n\n\nSignature: a.count(value, /)\nDocstring: Return number of occurrences of value.\nType:      builtin_function_or_method\n\n\n\n\na.count('a')\n\n2\n\n\n\na.count('b')\n\n3\n\n\n\na.count('c')\n\n1\n\n\n(extend)\n\na=[1,2,3,4]\nb=[-1,-2,-3,-4]\n\n\na.extend(b)\na\n\n[1, 2, 3, 4, -1, -2, -3, -4]\n\n\n\na=[1,2,3,4]\nb=[-1,-2,-3,-4]\n\n\na.append(b)\n\n\na\n\n[1, 2, 3, 4, [-1, -2, -3, -4]]\n\n\n(index)\n\na=[11,22,'a',True, 22,'a']\na.index?\n\n\nSignature: a.index(value, start=0, stop=9223372036854775807, /)\nDocstring:\nReturn first index of value.\nRaises ValueError if the value is not present.\nType:      builtin_function_or_method\n\n\n\n\na.index(11)\n\n0\n\n\n\na.index(22)\n\n1\n\n\n\na.index('a')\n\n2\n\n\n\na.index(True)\n\n3\n\n\n(insert)\n\na=[11,22,33]\na.insert?\n\n\nSignature: a.insert(index, object, /)\nDocstring: Insert object before index.\nType:      builtin_function_or_method\n\n\n\n\na.insert(2,88) \na\n\n[11, 22, 88, 88, 33]\n\n\n(pop)\n\na=['a',1,2,'d']\na.pop?\n\n\nSignature: a.pop(index=-1, /)\nDocstring:\nRemove and return item at index (default last).\nRaises IndexError if list is empty or index is out of range.\nType:      builtin_function_or_method\n\n\n\n\na.pop() # index=-1 이므로 마지막원소가 나타남\n\n'd'\n\n\n\na # a는 마지막 원소가 사라진 상태\n\n['a', 1, 2]\n\n\n\na.pop(0) # index=0 이므로 첫번쨰 원소가 나타남\n\n'a'\n\n\n\na # a에는 첫번째 원소가 사라진 상태\n\n[1, 2]\n\n\n(remove)\n\na=['a',2,3,'d']\na.remove?\n\n\nSignature: a.remove(value, /)\nDocstring:\nRemove first occurrence of value.\nRaises ValueError if the value is not present.\nType:      builtin_function_or_method\n\n\n\n\na.remove('d')\n\n\na\n\n['a', 2, 3]\n\n\n\na.remove('a')\n\n\na\n\n[2, 3]\n\n\n(reverse)\n\na=[1,2,3,4]\na.reverse?\n\n\nSignature: a.reverse()\nDocstring: Reverse *IN PLACE*.\nType:      builtin_function_or_method\n\n\n\n\na.reverse()\na\n\n[4, 3, 2, 1]\n\n\n(sort)\n\na=[1,3,2,4]\na.sort?\n\n\nSignature: a.sort(*, key=None, reverse=False)\nDocstring:\nSort the list in ascending order and return None.\nThe sort is in-place (i.e. the list itself is modified) and stable (i.e. the\norder of two equal elements is maintained).\nIf a key function is given, apply it once to each list item and sort them,\nascending or descending, according to their function values.\nThe reverse flag can be set to sort in descending order.\nType:      builtin_function_or_method\n\n\n\n\na.sort()\na\n\n[1, 2, 3, 4]\n\n\n\na.sort(reverse=True)\na\n\n[4, 3, 2, 1]\n\n\n(다른예제들)\n\na=list('guebin')\na\n\n['g', 'u', 'e', 'b', 'i', 'n']\n\n\n\na.sort()\na\n\n['b', 'e', 'g', 'i', 'n', 'u']\n\n\n\na.sort(reverse=True)\na\n\n['u', 'n', 'i', 'g', 'e', 'b']\n\n\n\n\nJ. 중첩리스트\n- 리스트는 리스트를 원소로 받을 수 있으므로 아래와 같이 중첩된 리스트를 만들 수 있다.\n\nA = [[1,2,3],\n     [4,5,6],\n     [7,8,9]]\nA\n\n[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n\n- A는 1차원인 벡터가 아니라 2차원인 매트릭스로 이해할 수 있다. 구체적으로는 아래와 같은 매트릭스로 이해할 수 있다\n\\[\\bf{A}=\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9\n\\end{bmatrix}\\]\n- A에서 (2,1)의 원소를 뽑고싶다 = 4를 뽑고싶다\n\nA[1,0] # R에서는 이게 가능했죠\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[532], line 1\n----&gt; 1 A[1,0] # R에서는 이게 가능했죠\n\nTypeError: list indices must be integers or slices, not tuple\n\n\n\n\n실패\n\n\nA[1][0]\n\n4\n\n\n\n성공\n\n- 성공의 이유를 분석해보자.\n\nA\n\n[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n\n\nA[1]\n\n[4, 5, 6]\n\n\n\nA[1][0]\n\n4\n\n\n- 매트릭스는 아니지만 매트릭스 같음!\n\n1차원 배열을 다차원 배열로 확장할 수 있는 기본 아이디어를 제공함\n\n\n\nK. 리스트 컴프리헨션\n- 개념: 집합에서 \\(\\{10,20,30,40\\}=\\{10i: i=1,2,3,4\\}=\\big\\{10i: \\text{ for } i \\in \\{1,2,3,4\\}\\big\\}\\) 임을 떠올리자.\n\n[10,20,30,40]\n\n[10, 20, 30, 40]\n\n\n\n[10*i for i in [1,2,3,4]]\n\n[10, 20, 30, 40]\n\n\n- 예제1: 리스트 컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라.\n\n['SSSS','PPPP','AAAA','MMMM']\n\n['SSSS', 'PPPP', 'AAAA', 'MMMM']\n\n\n(풀이)\n\n[s*4 for s in 'SPAM']\n\n['SSSS', 'PPPP', 'AAAA', 'MMMM']\n\n\n- 예제2: 리스트컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라.\n\n['X1','X2','X3','Y1','Y2','Y3']\n\n['X1', 'X2', 'X3', 'Y1', 'Y2', 'Y3']\n\n\n(풀이)\n\n[i+j for i in 'XY' for j in '123']\n\n['X1', 'X2', 'X3', 'Y1', 'Y2', 'Y3']\n\n\n- 예제: 리스트컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라.\n\n['stat1', 'stat2', 'stat3', 'math1', 'math2', 'math3']\n\n['stat1', 'stat2', 'stat3', 'math1', 'math2', 'math3']\n\n\n(풀이)\n\n[i+j for i in ['stat','math'] for j in '123']\n\n['stat1', 'stat2', 'stat3', 'math1', 'math2', 'math3']\n\n\n(다른풀이) 비어있는 리스트를 만들고 for문을 쓰면 좀 복잡해진다.\n\nlst = [] \nfor x in ['stat','math']: \n    for y in '123': \n        lst.append(x+y)\nlst\n\n['stat1', 'stat2', 'stat3', 'math1', 'math2', 'math3']\n\n\n- 예제: 리스트컴프리헨션과 문자열 'jbnu'를 이용하여 아래와 같은 리스트를 만들어라.\n\n['j','b','n','u']\n\n['j', 'b', 'n', 'u']\n\n\n(풀이)\n\n[s for s in 'jbnu']\n\n['j', 'b', 'n', 'u']\n\n\n(다른풀이) 아래와 같이 풀면 된다는것은 알고 있음\n\nlist('jbnu')\n\n['j', 'b', 'n', 'u']\n\n\n- 예제: 리스트컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라.\n\n['X1', 'X2', 'X3', 'X4', 'X5', 'X6', 'X7', 'X8', 'X9', 'X10', 'X11', 'X12']\n\n['X1', 'X2', 'X3', 'X4', 'X5', 'X6', 'X7', 'X8', 'X9', 'X10', 'X11', 'X12']\n\n\n(풀이)\n\n['X'+str(i) for i in range(1,13)]\n\n['X1', 'X2', 'X3', 'X4', 'X5', 'X6', 'X7', 'X8', 'X9', 'X10', 'X11', 'X12']\n\n\n\n\nL. 리스트 컴프리헨션과 for문의 미묘한 차이\n(경우1)\n\nx=777 \nlst = [] \nfor x in 'jbnu': \n    lst = lst + [x]\nlst    \n\n['j', 'b', 'n', 'u']\n\n\n\nx\n\n'u'\n\n\n(경우2)\n\nx=777\nlst = [x for x in 'jbnu'] \nlst \n\n['j', 'b', 'n', 'u']\n\n\n\nx\n\n777\n\n\n\n진짜 미묘하게 다르죠?\n\n\n\nM. 연습문제들\n# 문제. 길이가 0인 리스트를 만들어라. (비어있는 리스트를 만들어라)\n(풀이)\n\na = []\n\n\nlen(a)\n\n0\n\n\n# 문제. 다음의 실행값 중 가장 큰 숫자가 나오는 보기를 골라라. (에러가 나는 코드는 정답에서 제외함)\n(a) len(3.14) \n(b) len([3.14]) \n(c) len('3.14') \n(풀이)\n\nlen('3.14') # c가 제일큼\n\n4\n\n\n# 문제. 리스트자료형의 +와 * 연산을 이용하여 아래와 같은 list를 생성하라.\n\n[1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]\n\n[1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]\n\n\nhint: 아래의 코드를 관찰해보세요\n\n[1]*1+[2]*2 \n\n[1, 2, 2]\n\n\n(풀이)\n\nlst =[]\nfor i in range(1,6):\n    lst.extend([i]*i)\nlst\n\n[1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]\n\n\n# 문제. 다음과 같은 리스트를 고려하자.\n\nlst = ['A','B','C','D','A','A','B','A','F','C','C','C','A']\n\n이 리스트에서 ‘A’ 혹은 ’B’의 숫자는 모두 몇개인가?\n(풀이)\n\nlst.count(\"A\")\n\n5\n\n\n\nlst.count(\"B\")\n\n2\n\n\n# 문제. 아래와 같은 문자열이 있다고 하자.\n\ntest_arr = 'ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSUGPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XAt3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/EnmZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbxNrRFi9wrf+M7Q== schacon@mylaptop.local'\n\n이 문자열에서 대문자의 수를 count하라.\nhint: str 자료형의 특수기능 .isupper() 를 이용할 것\n(풀이)\n\nsum([s.isupper() for s in test_arr])\n\n155\n\n\n# 문제. 리스트컴프리헨션을 이용하여 아래와 같은 리스트를 생성하라.\n['a',\n 'aa',\n 'aaa',\n 'aaaa',\n 'aaaaa',\n 'aaaaaa',\n 'aaaaaaa',\n 'aaaaaaaa',\n 'aaaaaaaaa',\n 'aaaaaaaaaa'] &lt;- a가 10개있음\n(풀이)\n\nlst = ['a'*i for i in range(1,11)]\nlst\n\n['a',\n 'aa',\n 'aaa',\n 'aaaa',\n 'aaaaa',\n 'aaaaaa',\n 'aaaaaaa',\n 'aaaaaaaa',\n 'aaaaaaaaa',\n 'aaaaaaaaaa']\n\n\n# 문제. 아래와 같은 리스트를 관찰하라.\n\nlst = ['2022/09/21','2022/10/30','2022/12/25','2023/01/01','2023/01/31','2023/03/20']\nlst\n\n['2022/09/21',\n '2022/10/30',\n '2022/12/25',\n '2023/01/01',\n '2023/01/31',\n '2023/03/20']\n\n\n이러한 리스트를 아래와 같은 리스트로 변환하는 코드를 작성하라.\n\n['2022-09-21', '2022-10-30', '2022-12-25', '2023-01-01', '2023-01-31', '2023-03-20']\n\n['2022-09-21',\n '2022-10-30',\n '2022-12-25',\n '2023-01-01',\n '2023-01-31',\n '2023-03-20']\n\n\nhint: string의 .replace()기능과 리스트 컴프리헨션의 응용\n(풀이)\n\n[l.replace('/','-') for l in lst]\n\n['2022-09-21',\n '2022-10-30',\n '2022-12-25',\n '2023-01-01',\n '2023-01-31',\n '2023-03-20']\n\n\n# 문제. 아래와 같이 하나의 특수문자로 이루어진 리스트를 고려하자.\n\nblock = ['■'] \n\n이를 이용하여 아래와 같은 결과를 출력하라.\n\n'■-■-■-■-■-■-■-■-■-■' # 여기에서 '■'는 모두 10개 있음\n\n'■-■-■-■-■-■-■-■-■-■'\n\n\n(풀이1)\n\n'-'.join(block*10)\n\n'■-■-■-■-■-■-■-■-■-■'\n\n\n(풀이2)\n\n((block[0]+'-')*10)[:-1]\n\n'■-■-■-■-■-■-■-■-■-■'"
  },
  {
    "objectID": "content/05wk-2.html#hw",
    "href": "content/05wk-2.html#hw",
    "title": "05wk-2: [Python] – str, list // 숙제",
    "section": "3. HW",
    "text": "3. HW\n1. 아래를 출력하는 코드를 작성하라.\n11x1=11\n11x2=22\n11x3=33\n...\n19x17=323\n19x18=342\n19x19=361\n2. 아래와 같은 리스트를 관찰하라.\n\nlst = ['2022/09/21','2022/10/30','2022/12/25','2023/01/01','2023/01/31','2023/03/20']\nlst\n\n['2022/09/21',\n '2022/10/30',\n '2022/12/25',\n '2023/01/01',\n '2023/01/31',\n '2023/03/20']\n\n\n이러한 리스트를 아래와 같은 리스트로 변환하는 코드를 작성하라.\n\n['2022-09-21.','2022-10-30.','2022-12-25.','2023-01-01.','2023-01-31.','2023-03-20.']\n\n['2022-09-21.',\n '2022-10-30.',\n '2022-12-25.',\n '2023-01-01.',\n '2023-01-31.',\n '2023-03-20.']"
  },
  {
    "objectID": "content/02wk-2.html#문제풀이",
    "href": "content/02wk-2.html#문제풀이",
    "title": "02wk-2: [R] – 문제풀이 (벡터인덱싱, if, for 연습) // 숙제",
    "section": "1. 문제풀이",
    "text": "1. 문제풀이\n# 예제 – 아래의 벡터를 고려하자.\n\nset.seed(43052)\nx = rnorm(100)\n\n(1) x의 원소중 그 값이 양수인 것은 모두 몇개인가?\n\nsum(x&gt;0)\n\n[1] 59\n\n\n(2) x의 평균을 구하여라.\n\nmean(x)\n\n[1] 0.1044026\n\n\n(3) x의 원소중 평균과 가장 가까운 값을 구하여라.\n(풀이1)\n\ndist = abs(x - mean(x)) \n# dist는 x와 x의 평균간의 차이를 나타내는 벡터\n\n\ntf_array &lt;- (dist == min(dist))\n# tf_array 는 길이가 100이고 true, false로만 구성된 array \n# 그런데 이 tf_array는 하나의 true값만 있고, 그 true값은 dist가 가장 작은 지점에서 true를 가짐\n\n\nx[tf_array]\n\n[1] 0.102093\n\n\n(풀이2)\n\nidx = which.min(dist)\n# idx 는 dist의 최소값이 존재하는 위치(index)가 저장되어 있음\n\n\nx[idx]\n\n[1] 0.102093\n\n\n새로운 문제 – dist에서 which.min을 쓰지 않고 위에서 구한 idx를 얻는 방법?\n\nwhich.min(dist)\n\n[1] 47\n\n\n\n(1:100)[dist==min(dist)]\n\n[1] 47\n\n\n#\n# 예제 – 아래의 벡터를 고려하자.\n\nset.seed(43052)\nx = sample(1:100,50)\nx\n\n [1]  8 55 56 41 88 39 59 65 51 87 49 14 98 78  4 11 64  9 16 33 60 22 53 76 45\n[26] 63 13 95 80 81 21 38 12 28  3 73 93 97 96 90  7 84 10 32 18 79 57 89 68 31\n\n\n(1) x의 원소중 짝수는 몇개 있는가?\n\n50 - sum(x %% 2)\n\n[1] 23\n\n\n\nsum((x %% 2) == 0)\n\n[1] 23\n\n\n(2) x의 원소중 가장 작은 홀수는 무엇인가?\n\nmin(x[(x %% 2) == 1])\n\n[1] 3\n\n\n#\n2010(나)6월평가원-4. 실수 \\(a\\) 가\n\\[\n\\frac{2^a + 2^{-a}}{2^a - 2^{-a}} = -2\n\\] 를 만족시킬 때, \\(4^a + 4^{-a}\\) 의 값은?\n\n$ $\n\n$ $\n\n$ $\n\n$ $\n\n$ $\n\n(풀이)\n\na = seq(from=-2, to =-0.1, 0.0001)\nf&lt;- function(a){\n    up = 2^(a) + 2^(-a)\n    down = 2^(a) - 2^(-a) \n    up/down \n}\nplot(a,f(a))\nabline(h=-2,col=2)\n#( 2^(a) + 2^(-a) ) / (2^(a) - 2^(-a))\n\n\n\n\n\n\n\n\n\na[which.min(abs(f(a)+2))]\n\n[1] -0.7925\n\n\n\nf(-0.7925)\n\n[1] -1.999961\n\n\n\n4^(-0.7925) + 4^(0.7925)\n\n[1] 3.333403\n\n\n\nc(5/2,10/3,17/4, 26/5, 37/6)\n\n[1] 2.500000 3.333333 4.250000 5.200000 6.166667\n\n\n2024수능-16. 방정식 \\(3^{x-8} = \\left(\\frac{1}{27}\\right)^x\\) 을 만족시키는 실수 \\(x\\)의 값을 구하시오. [3점]\n(풀이)\n\nx = seq(from = -5, to=5, by =0.1)\nl = 3^(x-8) - (1/27)^x\nx[which.min(abs(l))]\n\n[1] 2\n\n\n2021(가)9월평가원-10. 수열 \\(\\{a_n\\}\\)은 \\(a_1 = 12\\)이고, 모든 자연수 \\(n\\)에 대하여\n\\[\na_{n+1} + a_n = (-1)^{n+1} \\times n\n\\] 을 만족시킨다. \\(a_k &gt; a_1\\)인 자연수 \\(k\\)의 최소값은?\n\n2\n\n4\n\n6\n\n8\n10\n\n(풀이)\n\na = c()\na\n\nNULL\n\n\n\na = c() \na[1] = 12\nfor(n in 1:100){\n    a[n+1] = - a[n] + (-1)^(n+1) * n \n}\n(1:100)[a&gt;a[1]]\n\n [1]   8  10  12  14  16  18  20  22  24  26  28  30  32  34  36  38  40  42  44\n[20]  46  48  50  52  54  56  58  60  62  64  66  68  70  72  74  76  78  80  82\n[39]  84  86  88  90  92  94  96  98 100\n\n\n답은 8\n2007(나)6월평가원-14. 다음은 어느 회사의 연봉에 대한 규정이다.\n(가) 입사 첫째 해 연봉은 \\(a\\)원이고, 입사 19년째 해까지의 연봉은 해마다 직전 연봉에서 8%씩 인상된다.\n(나) 입사 20년째 해부터의 연봉은 입사 19년째 해 연봉의 \\(2/3\\)로 한다.\n이 회사에 입사한 사람이 28년 동안 근무하여 받는 연봉의 총합은? (단, \\(1.08^{18} = 4\\)로 계산한다.)\n\n\\(\\frac{101}{2} a\\)\n\n\\(\\frac{111}{2} a\\)\n\n\\(\\frac{121}{2} a\\)\n\n\\(\\frac{131}{2} a\\)\n\\(\\frac{141}{2} a\\)\n\n(풀이)\n\na = 1\nsal = c()\nsal[1] = a\nfor(y in 2:19){\n    sal[y] &lt;- sal[y-1] * 1.08 \n}\nfor(y in 20:28){\n    sal[y] &lt;- sal[19] * 2/3 \n}\nsum(sal)\n\n[1] 65.42238"
  },
  {
    "objectID": "content/02wk-2.html#숙제",
    "href": "content/02wk-2.html#숙제",
    "title": "02wk-2: [R] – 문제풀이 (벡터인덱싱, if, for 연습) // 숙제",
    "section": "2. 숙제",
    "text": "2. 숙제\n1. \\(\\frac{3}{2}&lt; \\theta &lt; 2\\pi\\) 인 \\(\\theta\\) 에 대하여 \\(\\cos(\\theta)= \\frac{\\sqrt{6}}{3}\\) 을 만족하는 \\(\\theta\\) 값을 구하라.\n(풀이)\n\ntheta = seq(from=3/2,to=2*pi,length=100)\n\n\n# plot(theta, cos(theta), type='l')\n# abline(h=sqrt(6)/3,col=2)\n# 5~6사이에 답이 있는듯 \n\nNULL\n\n\n\ntheta[abs(cos(theta)-sqrt(6)/3) == min(abs(cos(theta)-sqrt(6)/3))]\n\n[1] 5.65509\n\n\n2. 어떤 회사에서는 연봉이 매년 일정한 규칙에 따라 인상된다.\n\n입사 첫해 연봉은 4000만 원이다.\n\n다음 해부터는 전년도 연봉의 8%를 인상한 후, 추가로 100만 원을 더해 결정한다.\n\n즉, 연봉을 \\(a_n\\)이라 하면 다음과 같은 관계식을 따른다. (단위는 만원)\n\\[\n\\begin{cases}\na_1 = 4000 & \\\\\na_n = a_{n-1} \\times 1.08 + 100 & n=2,3,\\dots\n\\end{cases}\n\\]\n이 회사에서 20년 동안 근무했을 때, 받는 총 연봉의 합은 얼마인가?\n(풀이)\n\na = c()\na[1] = 4000 \nfor(n in 2:20){\n    a[n] = a[n-1] * 1.08 + 100 \n}\nsum(a)\n\n[1] 215250.3"
  },
  {
    "objectID": "content/03wk-2.html#if",
    "href": "content/03wk-2.html#if",
    "title": "03wk-2: [R] – if, if-else, if-elseif-else // 숙제",
    "section": "1. if",
    "text": "1. if\n# 예제1 – if문은 if (조건문) 표현식의 형태로 사용한다.\n\na = 2\nif (a&gt;0) print('a는 양수') \n\n[1] \"a는 양수\"\n\n\n#\n# 예제2 – space를 임의로 넣어도 OK\n\na=10\nif    (a&gt;0)    print('a는 양수') \n\n[1] \"a는 양수\"\n\n\n\na=10\nif  (a&gt;0)    print('a는 양수') \n\n[1] \"a는 양수\"\n\n\n\na=10\nif(a&gt;0)    print('a는 양수') \n\n[1] \"a는 양수\"\n\n\n#\n# 예제3 – enter 를 임의로 넣어도 OK\n\na=10\nif (a&gt;0)\n    print('a는양수')\n\n[1] \"a는양수\"\n\n\n\na=10\nif (a&gt;0) \n    \n    \n    print('a는양수')\n\n[1] \"a는양수\"\n\n\n\na=10\nif \n    \n    \n    (a&gt;0) \n    \n    \n    print('a는양수')\n\n[1] \"a는양수\"\n\n\n#\n# 예제4 – if가 만족될때 내릴 명령이 2개이상이면 중괄호를 이용하라.\n잘못된 사용\n\na=10 \nif (a&gt;0)\n    print('a는양수')\n    print('양수인 a의 값은 아래와 같다.') \n    print(a) \n\n[1] \"a는양수\"\n,[1] \"양수인 a의 값은 아래와 같다.\"\n,[1] 10\n\n\n\na=-10 \nif (a&gt;0)\n    print('a는양수')\n    print('양수인 a의 값은 아래와 같다.') \n    print(a) \n\n[1] \"양수인 a의 값은 아래와 같다.\"\n,[1] -10\n\n\n\n컴퓨터에게 내릴 명령이 2개이상일 경우? \\(\\to\\) {}을 이용한다. 위의 코드들은 잘못된 코드이다. (에러메시지는 뜨지 않았지만)\n\n올바른 사용법: {}를 이용하여 명령들을 묶는다.\n\na=10 \nif (a&gt;0){\n    print('a는양수')\n    print('양수인 a의 값은 아래와 같다.') \n    print(a) \n}\n\n[1] \"a는양수\"\n,[1] \"양수인 a의 값은 아래와 같다.\"\n,[1] 10\n\n\n\na=-10 \nif (a&gt;0){\n    print('a는양수') ## \n    print('양수인 a의 값은 아래와 같다.') \n    print(a)\n}\n\n#\n# 예제5 – 중괄호를 묶는 방식\n아래와 같이 중괄호를 묶어도 상관없다.\n\na=10\nif (a&gt;0)\n{\n    print('a는양수')\n    print('양수인 a의 값은 아래와 같다.') \n    print(a) \n}\n\n[1] \"a는양수\"\n,[1] \"양수인 a의 값은 아래와 같다.\"\n,[1] 10\n\n\n\na=10\nif (a&gt;0)\n{\n    print('a는양수')\n    \n    print('양수인 a의 값은 아래와 같다.') \n    \n    \n    print(a)}\n\n[1] \"a는양수\"\n,[1] \"양수인 a의 값은 아래와 같다.\"\n,[1] 10\n\n\n\na=10\nif (a&gt;0){\n    print('a는양수')\n    \n            print('양수인 a의 값은 아래와 같다.') \n       \nprint(a)\n                }\n\n[1] \"a는양수\"\n,[1] \"양수인 a의 값은 아래와 같다.\"\n,[1] 10\n\n\n\n가능은 하지만 굳이 위와 같은 방식으로 중괄호를 만들 필요는 없다..\n\n#"
  },
  {
    "objectID": "content/03wk-2.html#if-else",
    "href": "content/03wk-2.html#if-else",
    "title": "03wk-2: [R] – if, if-else, if-elseif-else // 숙제",
    "section": "2. if-else",
    "text": "2. if-else\n# 예제1 – if문은 if (조건문) 표현식1 else 표현식2의 형태로 실행한다.\n\nx=2\nif (x&gt;0) log(x) else print('x는양수이어야함')\n\n[1] 0.6931472\n\n\n\nx=0\nif (x&gt;0) log(x) else print('x는양수이어야함')\n\n[1] \"x는양수이어야함\"\n\n\n\nx= -1\nif (x&gt;0) log(x) else print('x는양수이어야함')\n\n[1] \"x는양수이어야함\"\n\n\n#\n# 예제2 – if 문과 if~else 문은 다른기능이다. (\\(\\star\\star\\star\\))\n- 아래와 같이 사용해보자.\n\nx=10\nif (x&gt;0)\n    log(x) \nelse \n    print('x는 양수이어야함')\n\nError: Error in Unknown source: &lt;text&gt;:4:1: unexpected 'else'\n,3:     log(x) \n,4: else\n,   ^\n\n\n\n?? 왜 에러가 나는가?\n\n- 아래는 잘 실행된다.\n\nif (x&gt;0)    log(x)     else           print('x는양수이어야함')\n\n[1] 2.302585\n\n\n\nif (x&gt;0)    log(x)     else\n    print('x는양수이어야함')\n\n[1] 2.302585\n\n\n- 보통은 아래와 같이 사용한다.\n\nx=0\nif(x&gt;0){\n    log(x) \n}else{\n    print('x는 양수이어야함')\n}\n\n[1] \"x는 양수이어야함\"\n\n\n- 결국 한줄에 다 말하거나, 말을 하다가 끊어버리면 된다. // 한줄씩 끊어서 컴퓨터가 읽을떄 if문이 완성되면 안된다..\n- 아래와 같은것들도 가능\n\nx=0\nif (x&gt;0){\n    \nlog(x) \n    }else{\nprint('x는 양수이어야함')\n        }\n\n[1] \"x는 양수이어야함\"\n\n\n- 아래는 불가능\n\nx=0\nif (x&gt;0){\n    log(x) \n}\nelse{\n    print('x는 양수이어야함')\n}\n\nError: Error in Unknown source: &lt;text&gt;:5:1: unexpected 'else'\n,4: }\n,5: else\n,   ^\n\n\n\n중괄호만 친다고 해결되는게 아님\n\n- 결국 아래와 같은 코드를 권장함. (저는 무조건 이렇게만 씁니당)\n\nx=0\nif(x&gt;0){\n    log(x) \n}else{\n    print('x는 양수이어야함')\n}\n\n[1] \"x는 양수이어야함\"\n\n\n#"
  },
  {
    "objectID": "content/03wk-2.html#if-elseif-else",
    "href": "content/03wk-2.html#if-elseif-else",
    "title": "03wk-2: [R] – if, if-else, if-elseif-else // 숙제",
    "section": "3. if-elseif-else",
    "text": "3. if-elseif-else\n# 예제1\n\nx=10 \nif (x&gt;0){\n    print(log(x))\n}else{\n    if(x==0){\n        x=1e-100\n        print('x=0에서는 log(x)가 정의되지 않으므로 x=1e-100의 값으로 바꾸어 계산하겠습니다.')\n        print(log(x))\n    }else{ \n        print('x가음수입니다.')\n    }\n}\n\n[1] 2.302585\n\n\n\nx=0\nif (x&gt;0){\n    print(log(x))\n}else{\n    if(x==0){\n        x=1e-100\n        print('x=0에서는 log(x)가 정의되지 않으므로 x=1e-100의 값으로 바꾸어 계산하겠습니다.')\n        print(log(x))\n    }else{ \n        print('x가음수입니다.')\n    }\n}\n\n[1] \"x=0에서는 log(x)가 정의되지 않으므로 x=1e-100의 값으로 바꾸어 계산하겠습니다.\"\n,[1] -230.2585\n\n\n\nx=-1\nif (x&gt;0){\n    print(log(x))\n}else{\n    if(x==0){\n        x=1e-100\n        print('x=0에서는 log(x)가 정의되지 않으므로 x=1e-100의 값으로 바꾸어 계산하겠습니다.')\n        print(log(x))\n    }else{\n        print('x가음수입니다.')\n    }\n}\n\n[1] \"x가음수입니다.\"\n\n\n#\n# 예제2 – 예제1과 아래는 같은 코드이다.\n\nx=10 \nif (x&gt;0){\n    print(log(x))\n}else if(x==0){\n    x=1e-100\n    print('x=0에서는 log(x)가 정의되지 않으므로 x=1e-100의 값으로 바꾸어 계산하겠습니다.')\n    print(log(x))\n}else{ \n    print('x가음수입니다.')\n}\n\n[1] 2.302585\n\n\n\nx=0\nif (x&gt;0){\n    print(log(x))\n}else if(x==0){\n    x=1e-100\n    print('x=0에서는 log(x)가 정의되지 않으므로 x=1e-100의 값으로 바꾸어 계산하겠습니다.')\n    print(log(x))\n}else{ \n    print('x가음수입니다.')\n}\n\n[1] \"x=0에서는 log(x)가 정의되지 않으므로 x=1e-100의 값으로 바꾸어 계산하겠습니다.\"\n,[1] -230.2585\n\n\n\nx=-1\nif (x&gt;0){\n    print(log(x))\n}else if(x==0){\n    x=1e-100\n    print('x=0에서는 log(x)가 정의되지 않으므로 x=1e-100의 값으로 바꾸어 계산하겠습니다.')\n    print(log(x))\n}else{ \n    print('x가음수입니다.')\n}\n\n[1] \"x가음수입니다.\"\n\n\n#"
  },
  {
    "objectID": "content/03wk-2.html#숙제",
    "href": "content/03wk-2.html#숙제",
    "title": "03wk-2: [R] – if, if-else, if-elseif-else // 숙제",
    "section": "4. 숙제",
    "text": "4. 숙제\n1. 아래의 코드를 관찰하고 올바르게 고쳐라.\n\nx=-1\nif (x&gt;0){\n    print(log(x))\n}\nelse if(x==0){\n    x=1e-100\n    print('x=0에서는 log(x)가 정의되지 않으므로 x=1e-100의 값으로 바꾸어 계산하겠습니다.')\n    print(log(x))\n}else{ \n    print('x가음수입니다.')\n}\n\nError: Error in Unknown source: &lt;text&gt;:5:1: unexpected 'else'\n4: }\n5: else\n   ^\n\n\n(풀이)\n\nx=-1\nif (x&gt;0){\n    print(log(x))\n}else if(x==0){\n    x=1e-100\n    print('x=0에서는 log(x)가 정의되지 않으므로 x=1e-100의 값으로 바꾸어 계산하겠습니다.')\n    print(log(x))\n}else{ \n    print('x가음수입니다.')\n}\n\n[1] \"x가음수입니다.\"\n\n\n2. 함수 check가 올바르게 동작하도록 코드를 수정하라.\n\ncheck&lt;- function(x){\n    if(x%%2==0){\n        print(\"x는 2의 배수\")\n    }else if(x%%3==0){\n        print(\"x는 3의 배수\")\n    }else if(x%%6==0){\n        print(\"x는 2의 배수\")\n        print(\"x는 3의 배수\")\n    }else{\n        print(\"x는 3의 배수도 아니고, 2의 배수도 아니다\")\n    }\n}\n\n\ncheck(3)\n\n[1] \"x는 3의 배수\"\n\n\n\ncheck(4)\n\n[1] \"x는 2의 배수\"\n\n\n\ncheck(5)\n\n[1] \"x는 3의 배수도 아니고, 2의 배수도 아니다\"\n\n\n\ncheck(6) # 여기가 이상하게 나옴..\n\n[1] \"x는 2의 배수\"\n\n\n\ncheck(7)\n\n[1] \"x는 3의 배수도 아니고, 2의 배수도 아니다\"\n\n\n(풀이)\n\ncheck&lt;- function(x){\n    if(x%%6==0){\n        print(\"x는 2의 배수\")\n        print(\"x는 3의 배수\")\n    }else if(x%%2==0){\n        print(\"x는 2의 배수\")\n    }else if(x%%3==0){\n        print(\"x는 3의 배수\")\n    }else{\n        print(\"x는 3의 배수도 아니고, 2의 배수도 아니다\")\n    }\n}\n\n\ncheck(3)\n\n[1] \"x는 3의 배수\"\n\n\n\ncheck(4)\n\n[1] \"x는 2의 배수\"\n\n\n\ncheck(5)\n\n[1] \"x는 3의 배수도 아니고, 2의 배수도 아니다\"\n\n\n\ncheck(6) # 이제 잘나옴\n\n[1] \"x는 2의 배수\"\n[1] \"x는 3의 배수\"\n\n\n\ncheck(7)\n\n[1] \"x는 3의 배수도 아니고, 2의 배수도 아니다\""
  },
  {
    "objectID": "content/03wk-1.html#문제풀이",
    "href": "content/03wk-1.html#문제풀이",
    "title": "03wk-1: [R] – 문제풀이 (아홉개의 공, 100개의 라커) // 숙제",
    "section": "1. 문제풀이",
    "text": "1. 문제풀이\n# 예제 1 – 아홉개의 공\n아홉개의 공이있다. 이 가운데 여덟개는 무게가 같고 하나는 남은 하나는 좀 더 무겁다. 우리에게는 저울이 하나 있는데 이 저울로는 왼쪽의 공들이 무거운지 오른쪽의 공들이 무거운지밖에 알아낼 수 없다. 이 저울을 딱 두번만 사용하여 가장 무거운 공을 찾아내는 알고리즘을 solution 함수로 정리하여 제시하라. 공들의 무게는 길이가 9인 벡터로 온다고 가정한다. 출력은 가장 무거운 공이 위치한 index를 리턴하도록 한다.\n다음은 solution 함수를 실제로 구현하여 사용한 예시이다.\nsolution(c(2,1,1,1,1,1,1,1,1))\n&gt; 1\nsolution(c(2,2,5,2,2,2,2,2,2))\n&gt; 3\n(풀이)\n\nsolution &lt;- function(x){\n    l = x[1:3]\n    m = x[4:6]\n    r = x[7:9]\n    if(sum(l)&gt;sum(m)){\n        if(x[1]&gt;x[2]){\n            idx = 1 \n        }else if(x[1]&lt;x[2]){\n            idx = 2 \n        }else{\n            idx = 3 \n        }\n    }else if(sum(l)&lt;sum(m)){\n        if(x[4]&gt;x[5]){\n            idx = 4 \n        }else if(x[4]&lt;x[5]){\n            idx = 5\n        }else{\n            idx = 6 \n        }\n    }else{\n        if(x[7]&gt;x[8]){\n            idx = 7 \n        }else if(x[7]&lt;x[8]){\n            idx = 8\n        }else{\n            idx = 9 \n        }\n    }\n    return(idx)\n}\n\n\nsolution(c(2,1,1,1,1,1,1,1,1))\n\n1\n\n\n\nsolution(c(2,2,5,2,2,2,2,2,2))\n\n3\n\n\n#\n# 예제 2 – 100개의 라커\n복도에 100개의 라커가 있다. 복도를 어떤 남자가 100개의 라커 문을 전부 연다. 그리고 나서 짝수 번호의 라커를 전부 닫는다. 그 다음에는 번호가 3의 배수인 라커를 순서대로 찾아다니며 열려 있으면 닫고, 닫혀 있으면 연다. 그 다음에는 번호가 4의 배수인 라커를 순서대로 찾아다니며 열려있으면 닫고, 닫혀있으면 연다. 이후에 5의 배수, 6의 배수 .. 인 라커를 순서대로 찾아다니며 행동을 반복한다. 이런식으로 복도를 100번 지나가면 열린 라커의 문은 몇개가 되겠는가?\n\n#     라커1 라커2 라커3 라커4 라커5 라커6  ..... 라커100 \n# 1회  열    열    열   열   열    열    ..... 열 \n# 2회  열    닫    열   닫   열    닫    ..... 닫 \n# 3회  열    닫    닫   닫   열    열    ..... 닫 \n# 4회  열    닫    닫   열   열    열    ..... 닫 \n# ...\n\n# 알고리즘 \n# 1. 100개의 TRUE가 있는 벡터를 만듦. \n# 2. 100개의 TRUE가 있는 벡터에서 2,4,6,...,100 번쨰 원소를 선택하여 그 값을 반전시킴\n# 3. 100개의 TRUE가 있는 벡터에서 3,6,9,...,99 번쨰 원소를 선택하여 그 값을 반전시킴\n# ...\n# 100. 100개의 TRUE가 있는 벡터에서 100 번쨰 원소를 선택하여 그 값을 반전시킴\n\nNULL\n\n\n(예비학습)\n\nx = TRUE\n\n\n!x\n\n[1] FALSE\n\n\n\nx = c(TRUE, TRUE, FALSE)\n\n\n!x\n\n[1] FALSE FALSE  TRUE\n\n\n(풀이)\n\nflip &lt;- function(x){\n    !x\n}\n\n\ndoors = rep(TRUE,100)\nfor(i in 2:100){\n    doors[(1:100) %% i == 0] = flip(doors[(1:100) %% i == 0])\n}\nsum(doors)\n\n[1] 10\n\n\n#"
  },
  {
    "objectID": "content/03wk-1.html#숙제",
    "href": "content/03wk-1.html#숙제",
    "title": "03wk-1: [R] – 문제풀이 (아홉개의 공, 100개의 라커) // 숙제",
    "section": "2. 숙제",
    "text": "2. 숙제\n1 – 세 개의 공\n세 개의 공이 있다. 이 중 두 개는 무게가 같고, 하나는 더 가볍다. 우리는 저울을 한 번만 사용하여 가장 가벼운 공이 위치한 index를 찾아야 한다.\n이 문제를 해결하는 solution 함수를 작성하라. 공들의 무게는 길이가 3인 벡터로 주어진다고 가정한다. 출력은 가장 가벼운 공의 index가 되어야 한다.\n(풀이)\n\nsol &lt;- function(x){\n    idx = 0\n    if(x[1]&lt;x[2]){\n        idx = 1 \n    }else if(x[1]&gt;x[2]){\n        idx = 2 \n    }else{\n        idx = 3\n    }\n    return(idx)\n}\n\n\nsol(c(1,1,0.5))\n\n[1] 3\n\n\n2 - 10개의 라커\n복도에 10개의 라커가 있다. 복도를 어떤 남자가 10개의 라커 문을 전부 연다. 그리고 나서 짝수 번호의 라커를 전부 닫는다. 그 다음에는 번호가 3의 배수인 라커를 순서대로 찾아다니며 열려 있으면 닫고, 닫혀 있으면 연다. 그 다음에는 번호가 4의 배수인 라커를 순서대로 찾아다니며 열려있으면 닫고, 닫혀있으면 연다. 열린 라커의 문은 몇개가 되겠는가?\n\ndoors = rep(TRUE,10)\ndoors\n\n [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n\n\n\ndoors[seq(2,10,by=2)] = !doors[seq(2,10,by=2)]\n\n\ndoors[seq(3,10,by=3)] = !doors[seq(3,10,by=3)]\n\n\ndoors[seq(4,10,by=4)] = !doors[seq(4,10,by=4)]\n\n\nsum(doors)\n\n[1] 6\n\n\n참고코드\n1~10까지의 수 중에서 2의 배수이거나 3의배수를 뽑는 코드\n\n(1:10)[(1:10) %% 2 == 0] # 2의 배수를 뽑는 코드\n\n[1]  2  4  6  8 10\n\n\n\n(1:10)[(1:10) %% 3 == 0] # 3의 배수를 뽑는 코드\n\n[1] 3 6 9\n\n\n\n(1:10) %% 2 == 0 # 2의 배수 자리면 TRUE 그렇지 않으면 FALSE\n\n [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE\n\n\n\n(1:10) %% 3 == 0 # 3의 배수 자리면 TRUE 그렇지 않으면 FALSE\n\n [1] FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE\n\n\n\n(1:10)[((1:10) %% 2 == 0) | ((1:10) %% 3 == 0)] # 2의 배수이거나 3의 배수를 뽑는 코드\n\n[1]  2  3  4  6  8  9 10"
  },
  {
    "objectID": "content/05wk-1.html#intro",
    "href": "content/05wk-1.html#intro",
    "title": "05wk-1: [Python] – int, float, bool, str // 숙제",
    "section": "1. Intro",
    "text": "1. Intro\n- 파이썬의 기본자료형은 int, float, bool, str, list, tuple, dict, set 등이 있다.\n\n0차원 자료형: int, float, bool\n1차원 자료형: str, list, tuple, dict, set"
  },
  {
    "objectID": "content/05wk-1.html#int-float-bool",
    "href": "content/05wk-1.html#int-float-bool",
    "title": "05wk-1: [Python] – int, float, bool, str // 숙제",
    "section": "2. int, float, bool",
    "text": "2. int, float, bool\n- int형\n\na=100\n\n\ntype(a)\n\nint\n\n\n- float형\n\na=1.2*3\na\n\n3.5999999999999996\n\n\n\ntype(a)\n\nfloat\n\n\n\na?\n\n\nType:        float\nString form: 3.5999999999999996\nDocstring:   Convert a string or number to a floating point number, if possible.\n\n\n\n\n- bool형\n\na=True ## 숫자1으로 생각할 수 있음 \nb=False ## 숫자0으로 생각할 수 있음\n\n\ntype(a)\n\nbool\n\n\n\ntype(b)\n\nbool\n\n\n\na?\n\n\nType:        bool\nString form: True\nDocstring:  \nbool(x) -&gt; bool\nReturns True when the argument x is true, False otherwise.\nThe builtins True and False are the only two instances of the class bool.\nThe class bool is a subclass of the class int, and cannot be subclassed.\n\n\n\n\n\nb?\n\n\nType:        bool\nString form: False\nDocstring:  \nbool(x) -&gt; bool\nReturns True when the argument x is true, False otherwise.\nThe builtins True and False are the only two instances of the class bool.\nThe class bool is a subclass of the class int, and cannot be subclassed.\n\n\n\n\n- bool형의 연산\n\na=True ## 1\nb=False ## 0 \n\n\na+b\n\n1\n\n\n\na*b \n\n0\n\n\n- complex형\n\na=1+2j\nb=2-2j\n\n\ntype(a)\n\ncomplex\n\n\n\ntype(b)\n\ncomplex\n\n\n\na?\n\n\nType:        complex\nString form: (1+2j)\nDocstring:  \nCreate a complex number from a real part and an optional imaginary part.\nThis is equivalent to (real + imag*1j) where imag defaults to 0.\n\n\n\n\n\nb?\n\n\nType:        complex\nString form: (2-2j)\nDocstring:  \nCreate a complex number from a real part and an optional imaginary part.\nThis is equivalent to (real + imag*1j) where imag defaults to 0.\n\n\n\n\n\nc=a+b\n\n\nc\n\n(3+0j)\n\n\n- 형태변환: float \\(\\to\\) int\n(예시1)\n\na=3.0\ntype(a)\n\nfloat\n\n\n\na=int(a)\n\n\ntype(a)\n\nint\n\n\n(예시2) 이경우는 정보의 손실이 발생\n\na=3.14 \nint(a)\n\n3\n\n\n- 형태변환: int \\(\\to\\) float\n\na=3\ntype(a)\n\nint\n\n\n\na=float(a)\ntype(a)\n\nfloat\n\n\n- 형태변환: bool \\(\\to\\) int/float, int/float \\(\\to\\) bool\n(예시1)\n\na=True\ntype(a)\n\nbool\n\n\n\nint(a)\n\n1\n\n\n\nfloat(a)\n\n1.0\n\n\n(예시2)\n\na=1 \nbool(a)\n\nTrue\n\n\n\na=0\nbool(a)\n\nFalse\n\n\n(예시3)\n\na=1.0\nbool(a)\n\nTrue\n\n\n\na=0.0\nbool(a)\n\nFalse\n\n\n- 이상한 형태변환도 가능하다. (이런것도 바꿔주나 싶은것도 바꿔줌)\n\nbool(-3.14)\n\nTrue\n\n\n\n저는 이런 코드를 의도적으로 사용하지 않아요..\n\n\nint(3.14)\n\n3\n\n\n- 형태변환이 항상가능한것도 아님\n\nfloat(3+0j) # 사실상 3+0j=3 이므로 float으로 형변환하면 3.0이 되어야 할 것 같은데 변환불가능하다. \n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nInput In [78], in &lt;module&gt;\n----&gt; 1 float(3+0j)\n\nTypeError: can't convert complex to float\n\n\n\n- 암묵적형변환 (implicit)\n(예비학습) implicit의 의미\n\n추운날씨 -&gt; 보일러좀 틀자! (explicit) / 오늘 날씨 좀 추운 것 같지 않아? (implicit)\n짜장면 먹을래? -&gt; 싫어! (explicit) / 난 어제 짜장면 먹었는데.. (implicit)\n\n(예제)\n\nTrue * 1 # 1을 곱할건데 너 계속 True로 있을꺼야? \n\n1\n\n\n\n1 * 1.0 # 1.0을 곱할건데 너 계속 int로 있을꺼야? \n\n1.0\n\n\n\nTrue+True # +연산을 할건데 계속 True로 있을꺼야? \n\n2"
  },
  {
    "objectID": "content/05wk-1.html#str-기본내용",
    "href": "content/05wk-1.html#str-기본내용",
    "title": "05wk-1: [Python] – int, float, bool, str // 숙제",
    "section": "3. str 기본내용",
    "text": "3. str 기본내용\n\nA. 선언\n- 예시1\n\na='guebin'\n\n\na\n\n'guebin'\n\n\n- 예시2\n\na=\"guebin\"\n\n\na\n\n'guebin'\n\n\n\n\nB. 연산\n- 더하기(+)연산\n\na='X'\nb='2'\n\n\nc=a+b\nc\n\n'X2'\n\n\n- 빼기(-)연산\n\na='X2'\nb='2'\na-b\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nInput In [92], in &lt;module&gt;\n      1 a='X2'\n      2 b='2'\n----&gt; 3 a-b\n\nTypeError: unsupported operand type(s) for -: 'str' and 'str'\n\n\n\n\n이런건 없다.\n\n- 곱하기(*)연산\n\na='X'\n\n\na+a+a\n\n'XXX'\n\n\n\na*3 # a*3 = a+a+a = 'X'+'X+'X'\n\n'XXX'\n\n\n아래도 가능하다.\n\n3*a\n\n'XXX'\n\n\n그리고 아래도 가능하다.\n\na='X'\nb=3 \na*b\n\n'XXX'\n\n\n대신에 의미상 맞지 않는 것은 수행되지 않고 에러가 난다.\n\na='X'\nb='Y'\na+b\n\n'XY'\n\n\n\na*b\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[70], line 1\n----&gt; 1 a*b\n\nTypeError: can't multiply sequence by non-int of type 'str'\n\n\n\n- 나눗셈(/)연산\n\na='XX'\n\n\na/2\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[73], line 1\n----&gt; 1 a/2\n\nTypeError: unsupported operand type(s) for /: 'str' and 'int'\n\n\n\n\n이런건 없다..\n\n\n\nC. 인덱싱\n- str은 하나의 벡터 문자가 여러개 있는 형태라고 생각하면 된다.\n\na='guebin'\n\n\na\n\n'guebin'\n\n\n\n6개의 칸에 글씨가 하나씩 들어가 있음.\n\n- 대괄호 []안에 숫자를 넣는 방식으로 벡터의 원소를 호출할 수 있다. (주의: 인덱스가 0부터 시작함)\n\na[0] #첫번째원소\n\n'g'\n\n\n\na[1] #두번째원소 \n\n'u'\n\n\n마지막원소는 -1로 호출할 수도 있다.\n\na[-1]\n\n'n'\n\n\n마지막에서 2번째 원소는 -2로 호출가능하다.\n\na[-2]\n\n'i'\n\n\n- 요약하면 아래와 같은 방식으로 호출가능함.\n\n\n\ng\nu\ne\nb\ni\nn\n\n\n\n\n0\n1\n2\n3\n4\n5\n\n\n0\n-5\n-4\n-3\n-2\n-1\n\n\n\n\na[4]\n\n'i'\n\n\n\na[-2]\n\n'i'\n\n\n\na[-4]\n\n'e'\n\n\n- :을 이용하여 여러개의 원소를 호출할 수 있음.\n\na='guebin'\n\n\na[0:3] # a[0],a[1],a[2],a[3]이 아니라 a[0],a[1],a[2]까지만 뽑힌다. 즉 마지막의 3은 호출되지 않는다. \n\n'gue'\n\n\n\na[1:3] # a[1], a[2] 만 호출 // start=1,  stop=3 \n\n'ue'\n\n\nindex=1부터 시작해서 마지막원소까지 호출하려면?\n\na='guebin'\n\n\na[5] # guebin의 마지막원소 'n'이 출려 \n\n'n'\n\n\n\na[1:5] # 5는 포함되지 않으므로 틀림\n\n'uebi'\n\n\n\na[1:6] # 정답\n\n'uebin'\n\n\n안 헷갈리는 방법은 없을까? 생략한다.\n\na[1:]\n\n'uebin'\n\n\n- 생략의 응용1\n\na='k-pop' \na\n\n'k-pop'\n\n\n\na[2:5]\n\n'pop'\n\n\n\na[2:]\n\n'pop'\n\n\n- 생략의 응용2\n\na='k-pop'\na\n\n'k-pop'\n\n\n\na[0:2] # a[0],a[1]\n\n'k-'\n\n\n\na[:2] # a[0],a[1] \n\n'k-'\n\n\n- 생략의 응용3\n\na='k-pop'\na\n\n'k-pop'\n\n\n\na[0:5] # a[0],...,a[4]\n\n'k-pop'\n\n\n\na[:]\n\n'k-pop'\n\n\n\n\nD. str 특수기능\n- 파이썬의 변수는 단순히 정보를 담는 그릇이 아니다. 유용한 기능을 제공하는 경우가 있다.\n\na='ABCD' # a라는 변수는 'ABCD'라는 정보를 담는 그릇의 역할만 하지 않고, 특화된 어떠한 기능도 제공한다. \na\n\n'ABCD'\n\n\n\na.lower() # a.lower()를 쓰면 a의 모든 문자를 소문자로 바꾸는 기능을 제공, lower(a)라고 읽자!\n\n'abcd'\n\n\n여기에서 lower()는 문자열에 특화된 기능임. 따라서 당연히 아래는 불가능\n\na=3.14\na.lower() # lower(a)\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nInput In [194], in &lt;module&gt;\n      1 a=3.14\n----&gt; 2 a.lower()\n\nAttributeError: 'float' object has no attribute 'lower'\n\n\n\n- 자료형에 특화된 기능(=함수)을 확인하는 방법? a.+ tab 으로 목록 확인 가능\n\na='guebin'\n\n\na.upper?\n\n\nSignature: a.upper()\nDocstring: Return a copy of the string converted to uppercase.\nType:      builtin_function_or_method\n\n\n\n\na.upper() # upper(a) \n\n'GUEBIN'\n\n\n\na.capitalize() # capitalize(a) \n\n'Guebin'\n\n\n\na='asdf'\n\n\na.replace(\"d\",\"D\")\n\n'asDf'\n\n\n- 문자열에 대한 다른 내용들은 추후에 다루겠음.\n- 마음의눈: a.f() 형태를 읽는 팁\n\na.f()는 f(a)로 생각하면 편리함.\na.f(2)는 f(a,2)로 생각하면 편리함.\n이런점에서 R %&gt;% 연산자와 비슷하다고 생각할 수 있다. (약간 다르긴함)\n\n- 사실 .은 좀 더 다양한 상황에서 쓰일 수 있다. 변수이름.함수이름() 의 형태가 아니라\n\n패지키이름.함수이름()\n패키지이름.변수이름\n패키지이름.패키지이름.함수이름()\n…\n\n와 같이 다양한 형태가 가능하다. 근본적인 공통점은 .을 기준으로 상위개념.하위개념 으로 이해하는 것이 좋다.\n\n\nE. len\n- len함수 소개: 원소의 갯수를 알려주는 함수.\n\na='ABCD' \nlen(a)\n\n4\n\n\n- 참고: len은 0차원 변수형에서는 동작하지 않고 1차원 변수형에서만 동작한다.\n(0차원) len 함수가 동작하지 않음.\n\na=3.14\n\n\nlen(a)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[210], line 1\n----&gt; 1 len(a)\n\nTypeError: object of type 'float' has no len()\n\n\n\n\nb=True\n\n\nlen(b)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[212], line 1\n----&gt; 1 len(b)\n\nTypeError: object of type 'bool' has no len()\n\n\n\n(1차원) len 함수가 잘 동작함.\n\na='3.14'\nlen(a)\n\n4\n\n\n\nb=[1,2,3]\n\n\nlen(b)\n\n3"
  },
  {
    "objectID": "content/05wk-1.html#숙제",
    "href": "content/05wk-1.html#숙제",
    "title": "05wk-1: [Python] – int, float, bool, str // 숙제",
    "section": "4. 숙제",
    "text": "4. 숙제\n1. 아래와 같은 문자열이 있다고 하자.\n\na = 'Jeonbuk National University'\na\n\n'Jeonbuk National University'\n\n\n적당한 인덱싱을 통하여 출력결과가 아래와 같도록 하라.\n\n'University'\n\n'University'\n\n\n\nhint: University는 10글자이다.\n\n2. 아래와 같은 문자열이 있다고 하자.\n\na = 'ASDF'\na\n\n'ASDF'\n\n\n출력결과가 아래와 같도록 하는 코드를 작성하라. (lower 함수를 이용할 것)\n\n'asdf'\n\n'asdf'\n\n\n3. 아래와 같은 문자열을 고려하라.\n\na = '2021. 01. 05.'\na\n\n'2021. 01. 05.'\n\n\n띄어쓰기를 제거하는 코드를 구현하라. 즉 출력결과가 아래와 같도록 만드는 코드를 구현하라. (.replace() 를 이용할 것)\n\n'2021.01.05.'\n\n'2021.01.05.'"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "IAB프로그램 (2025)",
    "section": "",
    "text": "실습\n\nhttps://guebin.github.io/IAB2025-Play\n\n질문하는 방법\n\n이메일: guebin@jbnu.ac.kr\n직접방문: 자연과학대학 본관 205호\nZoom: 이메일로 미리 시간을 정할 것\n카카오톡: http://pf.kakao.com/_txeIFG/chat\n\n강의노트\n\n\n\n\n\n\n\n\n\nDate\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nApr 3, 2025\n\n\n05wk-2: [Python] – str, list // 숙제\n\n\n최규빈 \n\n\n\n\nApr 1, 2025\n\n\n05wk-1: [Python] – int, float, bool, str // 숙제\n\n\n최규빈 \n\n\n\n\nMar 27, 2025\n\n\n04wk-2: 벡터와 행렬의 결합, 벡터관련 연산, 자료의 변환 // 숙제\n\n\n최규빈 \n\n\n\n\nMar 25, 2025\n\n\n04wk-1: [R] – 10개의 라커, 매트릭스, 파이프연산자 // 숙제\n\n\n최규빈 \n\n\n\n\nMar 20, 2025\n\n\n03wk-2: [R] – if, if-else, if-elseif-else // 숙제\n\n\n최규빈 \n\n\n\n\nMar 18, 2025\n\n\n03wk-1: [R] – 문제풀이 (아홉개의 공, 100개의 라커) // 숙제\n\n\n최규빈 \n\n\n\n\nMar 13, 2025\n\n\n02wk-2: [R] – 문제풀이 (벡터인덱싱, if, for 연습) // 숙제\n\n\n최규빈 \n\n\n\n\nMar 11, 2025\n\n\n02wk-1: [R] – 문제풀이, Bool 자료형과 조건판단, 벡터인덱싱, 조건문과 반복문 // 숙제\n\n\n최규빈 \n\n\n\n\nMar 6, 2025\n\n\n01wk-2: [R] – 문제풀이, 변수 이름 선언, 벡터의 선언, 함수의 선언\n\n\n최규빈 \n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/04wk-1.html#개의-라커",
    "href": "content/04wk-1.html#개의-라커",
    "title": "04wk-1: [R] – 10개의 라커, 매트릭스, 파이프연산자 // 숙제",
    "section": "1. 10개의 라커",
    "text": "1. 10개의 라커\n1. 복도에 10개의 라커가 있다. 복도를 어떤 남자가 10개의 라커 문을 전부 연다. 그리고 나서 짝수 번호의 라커를 전부 닫는다. 그 다음에는 번호가 3의 배수인 라커를 순서대로 찾아다니며 열려 있으면 닫고, 닫혀 있으면 연다. 그 다음에는 번호가 4의 배수인 라커를 순서대로 찾아다니며 열려있으면 닫고, 닫혀있으면 연다. 이러한 방식으로 6회차까지 진행한다. 열린 라커의 문은 몇개가 되겠는가?\n(풀이1)\n\ndoors = rep(TRUE,60)\ndim(doors) = c(10,6)\ndoors\n\n      [,1] [,2] [,3] [,4] [,5] [,6]\n [1,] TRUE TRUE TRUE TRUE TRUE TRUE\n [2,] TRUE TRUE TRUE TRUE TRUE TRUE\n [3,] TRUE TRUE TRUE TRUE TRUE TRUE\n [4,] TRUE TRUE TRUE TRUE TRUE TRUE\n [5,] TRUE TRUE TRUE TRUE TRUE TRUE\n [6,] TRUE TRUE TRUE TRUE TRUE TRUE\n [7,] TRUE TRUE TRUE TRUE TRUE TRUE\n [8,] TRUE TRUE TRUE TRUE TRUE TRUE\n [9,] TRUE TRUE TRUE TRUE TRUE TRUE\n[10,] TRUE TRUE TRUE TRUE TRUE TRUE\n\n\n\nfor(n in 2:6){\n    doors[,n] = doors[,n-1]\n    doors[,n][seq(n,10,n)] = !doors[,n-1][seq(n,10,n)]\n}\n\n\ndoors\n\n      [,1]  [,2]  [,3]  [,4]  [,5]  [,6]\n [1,] TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [2,] TRUE FALSE FALSE FALSE FALSE FALSE\n [3,] TRUE  TRUE FALSE FALSE FALSE FALSE\n [4,] TRUE FALSE FALSE  TRUE  TRUE  TRUE\n [5,] TRUE  TRUE  TRUE  TRUE FALSE FALSE\n [6,] TRUE FALSE  TRUE  TRUE  TRUE FALSE\n [7,] TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [8,] TRUE FALSE FALSE  TRUE  TRUE  TRUE\n [9,] TRUE  TRUE FALSE FALSE FALSE FALSE\n[10,] TRUE FALSE FALSE FALSE  TRUE  TRUE\n\n\n\nsum(doors[,6])\n\n[1] 5\n\n\n(풀이2)\n\ndoors = rep(TRUE,10*6)\ndoors\n\n [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[31] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[46] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n\n\n\ndim(doors) = c(10,6)\ndoors\n\n      [,1] [,2] [,3] [,4] [,5] [,6]\n [1,] TRUE TRUE TRUE TRUE TRUE TRUE\n [2,] TRUE TRUE TRUE TRUE TRUE TRUE\n [3,] TRUE TRUE TRUE TRUE TRUE TRUE\n [4,] TRUE TRUE TRUE TRUE TRUE TRUE\n [5,] TRUE TRUE TRUE TRUE TRUE TRUE\n [6,] TRUE TRUE TRUE TRUE TRUE TRUE\n [7,] TRUE TRUE TRUE TRUE TRUE TRUE\n [8,] TRUE TRUE TRUE TRUE TRUE TRUE\n [9,] TRUE TRUE TRUE TRUE TRUE TRUE\n[10,] TRUE TRUE TRUE TRUE TRUE TRUE\n\n\n\nflip &lt;- function(doors, n){\n    doors[seq(n,10,n)] = !doors[seq(n,10,n)]\n    return(doors)\n}\n\n\nfor(n in 2:6){\n    doors[,n] = flip(doors[,n-1],n)\n}\n\n\ndoors\n\n      [,1]  [,2]  [,3]  [,4]  [,5]  [,6]\n [1,] TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [2,] TRUE FALSE FALSE FALSE FALSE FALSE\n [3,] TRUE  TRUE FALSE FALSE FALSE FALSE\n [4,] TRUE FALSE FALSE  TRUE  TRUE  TRUE\n [5,] TRUE  TRUE  TRUE  TRUE FALSE FALSE\n [6,] TRUE FALSE  TRUE  TRUE  TRUE FALSE\n [7,] TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [8,] TRUE FALSE FALSE  TRUE  TRUE  TRUE\n [9,] TRUE  TRUE FALSE FALSE FALSE FALSE\n[10,] TRUE FALSE FALSE FALSE  TRUE  TRUE\n\n\n\nsum(doors[,6])\n\n[1] 5\n\n\n2. 6번라커는 3회차에서 열려있는가 닫혀있는가?\n(풀이)\n\ndoors[6,3]\n\n[1] TRUE\n\n\n3. 8번라커는 6회차가 진행되는 동안 몇번이나 열림상태로 있는가?\n(풀이)\n\ndoors[8,]\n\n[1]  TRUE FALSE FALSE  TRUE  TRUE  TRUE\n\n\n\nsum(doors[8,])\n\n[1] 4\n\n\n4. 열고 닫힘이 가장 빈번한 라커는 몇번인가?\n(풀이1)\n\ndoors[6,]\n\n[1]  TRUE FALSE  TRUE  TRUE  TRUE FALSE\n\n\n\ndoors[6,]*1\n\n[1] 1 0 1 1 1 0\n\n\n\ndiff(doors[6,])\n\n[1] -1  1  0  0 -1\n\n\n\nabs(diff(doors[6,]))\n\n[1] 1 1 0 0 1\n\n\n\nsum(abs(diff(doors[6,])))\n\n[1] 3\n\n\n\ncount = rep(0,10)\nfor(n in 1:10){\n    count[n] &lt;- sum(abs(diff(doors[n,])))\n}\ncount\n\n [1] 0 1 1 2 1 3 0 2 1 2\n\n\n\nwhich.max(count)\n\n[1] 6\n\n\n(풀이2)\n\nlibrary(tidyverse)\n\n\ncount = rep(0,10)\nfor(n in 1:10){\n    count[n] &lt;- doors[n,] %&gt;% diff %&gt;% abs %&gt;% sum \n}\nwhich.max(count)\n\n[1] 6"
  },
  {
    "objectID": "content/04wk-1.html#matrix",
    "href": "content/04wk-1.html#matrix",
    "title": "04wk-1: [R] – 10개의 라커, 매트릭스, 파이프연산자 // 숙제",
    "section": "2. matrix",
    "text": "2. matrix\n\nA. 매트릭스를 선언하는 방법\n- 방법1: 벡터를 만들고, 그것을 row-vector로 해석한뒤 \\(\\to\\) bind\n\nrbind(c(1,2,3,4),c(2,3,4,5))\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    2    3    4    5\n\n\n- 방법2: 벡터를 만들고, 그것을 col-vector로 해석한뒤 \\(\\to\\) bind\n\ncbind(c(1,2,3,4),c(2,3,4,5))\n\n     [,1] [,2]\n[1,]    1    2\n[2,]    2    3\n[3,]    3    4\n[4,]    4    5\n\n\n참고: 만들어진 매트릭스의 차원을 살펴보는 방법\n\nA=rbind(c(1,2,3,4),c(2,3,4,5))\nA\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    2    3    4    5\n\n\n\ndim(A)\n\n[1] 2 4\n\n\n\nA=cbind(c(1,2,3,4),c(2,2,3,4))\nA\n\n     [,1] [,2]\n[1,]    1    2\n[2,]    2    2\n[3,]    3    3\n[4,]    4    4\n\n\n\ndim(A)\n\n[1] 4 2\n\n\n- 방법3: 벡터를 선언하고 dim()을 이용하여 차원을 강제셋팅\n\nA = 1:8\n\n\nA\n\n[1] 1 2 3 4 5 6 7 8\n\n\n\ndim(A)\n\nNULL\n\n\n\ndim(A) &lt;- c(2,4) \n\n\ndim(A)\n\n[1] 2 4\n\n\n\nA\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n\n\n\ndim(A) &lt;- c(4,2)\n\n\nA\n\n     [,1] [,2]\n[1,]    1    5\n[2,]    2    6\n[3,]    3    7\n[4,]    4    8\n\n\n\ndim(A) &lt;- c(3,3)\n\nError: Error in dim(A) &lt;- c(3, 3): dims [product 9] do not match the length of object [8]\n\n\n\n\nB. 매트릭스의 원소를 뽑는 방법\n- 아래와 같은 매트릭스가 있다고 하자.\n\nA=rbind(c(1,2,3,4),c(5,6,7,8),c(9,10,11,12))\nA\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n\n\n- 1열을 뽑고싶다.\n\nA[,1] \n\n[1] 1 5 9\n\n\n- 1열,4열을 뽑고싶다.\n\nA[,c(1,4)]\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    5    8\n[3,]    9   12\n\n\n- 2행을 뽑고싶다.\n\nA[2,]\n\n[1] 5 6 7 8\n\n\n- 1행과 2행을 뽑고싶다.\n\nA[c(1,2),]\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n\n\n\nA[1:2,]\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n\n\n- 2행3열의 원소를 뽑고싶다. 즉 (2,3)의 위치에 있는 원소를 뽑고싶다.\n\nA[2,3]\n\n[1] 7\n\n\n- 2열을 제외하고 뽑고 싶다.\n\nA[,-2]\n\n     [,1] [,2] [,3]\n[1,]    1    3    4\n[2,]    5    7    8\n[3,]    9   11   12\n\n\n\n\nC. 매트릭스를 왜 써야하는가?\n- 바둑판구조의 자료형을 표현하기 위해서 = 자료를 바둑판 구조로 저장하기 위해서\n- 자료를 바둑판(2d-array), 나아가 큐브형태(3d-array)로 저장하면 어떠한 이점이 있는가?\n- 자료를 벡터(1d-array)로 저장하면 어떠한 이점이 있는가? 와 같은 질문 - 프로그래밍 구조상의 이점 - 계산상의 이점\n- 자료를 벡터로 관리하면 어떠한 이점이 생기듯이 자료를 매트릭스로 관리해도 이점이 생긴다."
  },
  {
    "objectID": "content/04wk-1.html#파이프연산자",
    "href": "content/04wk-1.html#파이프연산자",
    "title": "04wk-1: [R] – 10개의 라커, 매트릭스, 파이프연산자 // 숙제",
    "section": "3. 파이프연산자",
    "text": "3. 파이프연산자\n\n%&gt;% 연산자 (\\(\\star\\star\\star\\))\n\nnote: 진짜 중요한 문법입니다. 너무편해요.\n\n- 아래는 같은코드이다.\n\nsum(1:10)\n\n[1] 55\n\n\n\n1:10 %&gt;% sum()\n\n[1] 55\n\n\n\n1:10 %&gt;% sum\n\n[1] 55\n\n\n- 아래와 같이 2개의 입력을 받는 함수를 생각하자.\n\nmyfun = function(x,y){\n    x**2+y\n}\n\n- 아래는 같은코드이다.\n\nmyfun(2,3)\n\n[1] 7\n\n\n\n2 %&gt;% myfun(3)\n\n[1] 7\n\n\n- 동일한 논리로 아래도 같은코드이다.\n\nmyfun(3,2) \n\n[1] 11\n\n\n\n3 %&gt;% myfun(2)\n\n[1] 11\n\n\n- 입력이 3개인 함수를 만들자.\n\nmyfun2= function(x,y,z){\n    x**2 + y*z\n}\n\n- 아래는 같은코드이다.\n\nmyfun2(2,1,1)\n\n[1] 5\n\n\n\n2 %&gt;% myfun2(1,1)\n\n[1] 5\n\n\n- 왜 이러한 일을 해야하는가? (합성함수 처리에 유리)\n\nx = c(1,100,2,3,4)\nx\n\n[1]   1 100   2   3   4\n\n\n\nx %&gt;% diff \n\n[1]  99 -98   1   1\n\n\n\nx %&gt;% diff %&gt;% abs %&gt;% sum %&gt;% log %&gt;% sqrt\n\n[1] 2.300718\n\n\n- 개념: x %&gt;% f %&gt;% h %&gt;% g 는 아래가 연산되는것\n\n\\(x \\overset{f}{\\to} f(x) \\overset{h}{\\to} h(f(x)) \\overset{g}{\\to} g(h(f(x)))\\)"
  },
  {
    "objectID": "content/04wk-1.html#hw",
    "href": "content/04wk-1.html#hw",
    "title": "04wk-1: [R] – 10개의 라커, 매트릭스, 파이프연산자 // 숙제",
    "section": "4. HW",
    "text": "4. HW\n복도에 100개의 라커가 있다. 복도를 어떤 남자가 100개의 라커 문을 전부 연다. 그리고 나서 짝수 번호의 라커를 전부 닫는다. 그 다음에는 번호가 3의 배수인 라커를 순서대로 찾아다니며 열려 있으면 닫고, 닫혀 있으면 연다. 그 다음에는 번호가 4의 배수인 라커를 순서대로 찾아다니며 열려있으면 닫고, 닫혀있으면 연다. 이러한 방식으로 50회차까지 진행한다. 48번 라커는 몇번의 열고 닫힘이 있는가?"
  },
  {
    "objectID": "content/02wk-1.html#문제풀이",
    "href": "content/02wk-1.html#문제풀이",
    "title": "02wk-1: [R] – 문제풀이, Bool 자료형과 조건판단, 벡터인덱싱, 조건문과 반복문 // 숙제",
    "section": "1. 문제풀이",
    "text": "1. 문제풀이\n2024수능-19. 함수 \\(f(x) = \\sin \\frac{\\pi}{4} x\\) 할 때, \\(0 &lt; x &lt; 16\\)에서 부등식\n\\[\nf(2+x) f(2-x) &lt; \\frac{1}{4}\n\\]\n을 만족시키는 모든 자연수 \\(x\\)의 값의 합을 구하시오. [3점]\n(풀이1)\n\nf = function(x){\n   sin(pi/4 *x) \n}\n\n\nx=1\nf(2+x)*f(2-x)\n\n[1] 0.5\n\n\n…\n\nx=15\nf(2+x)*f(2-x)\n\n[1] 0.5\n\n\n(풀이2)\n\nf = function(x){\n   sin(pi/4 *x) \n}\n\n\nx = 1:15\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15\n\n\n\ny = c(1,5,2,3)\ny\n\n[1] 1 5 2 3\n\n\n\nf(2+x) * f(2-x) &lt; 1/4\n\n [1] FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE\n[13] FALSE  TRUE FALSE\n\n\n\nx[f(2+x) * f(2-x) &lt; 1/4]\n\n[1]  2  6 10 14\n\n\n\nsum(x[f(2+x) * f(2-x) &lt; 1/4])\n\n[1] 32\n\n\n(풀이3)\n\ns = 0 \nfor(x in 1:15){\n    if(f(2+x)*f(2-x) &lt; 1/4){\n        s = s+x\n    }\n}\ns\n\n[1] 32"
  },
  {
    "objectID": "content/02wk-1.html#bool-자료형과-조건판단",
    "href": "content/02wk-1.html#bool-자료형과-조건판단",
    "title": "02wk-1: [R] – 문제풀이, Bool 자료형과 조건판단, 벡터인덱싱, 조건문과 반복문 // 숙제",
    "section": "2. Bool 자료형과 조건판단",
    "text": "2. Bool 자료형과 조건판단\n- 예시1\n\n2&gt;3\n\n[1] FALSE\n\n\n- 예시2\n\nx = 1:5\nx\n\n[1] 1 2 3 4 5\n\n\n\nx&gt;3\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\n\n\nx&lt;5\n\n[1]  TRUE  TRUE  TRUE  TRUE FALSE\n\n\n\nx&gt;=3\n\n[1] FALSE FALSE  TRUE  TRUE  TRUE\n\n\n\nx&lt;=5\n\n[1] TRUE TRUE TRUE TRUE TRUE\n\n\n\nx==3\n\n[1] FALSE FALSE  TRUE FALSE FALSE"
  },
  {
    "objectID": "content/02wk-1.html#벡터인덱싱",
    "href": "content/02wk-1.html#벡터인덱싱",
    "title": "02wk-1: [R] – 문제풀이, Bool 자료형과 조건판단, 벡터인덱싱, 조건문과 반복문 // 숙제",
    "section": "3. 벡터인덱싱",
    "text": "3. 벡터인덱싱\n\nA. 번호로 뽑는 방법\n\n벡터의 원소에 순서대로 번호를 매겨서 뽑는 방식\n\n# 예제1– 첫 원소를 뽑고싶다.\n\nx&lt;-c(1,2,-2,4,5,-5,6)\nx\n\n[1]  1  2 -2  4  5 -5  6\n\n\n\nx[1]\n\n[1] 1\n\n\n#\n# 예제2 – 세번째 원소를 뽑고싶다.\n\nx&lt;-c(1,2,-2,4,5,-5,6)\nx\n\n[1]  1  2 -2  4  5 -5  6\n\n\n\nx[3]\n\n[1] -2\n\n\n#\n# 예제3 – 첫번째부터 세번째까지의 원소를 뽑고싶다.\n\nx&lt;-c(1,2,-2,4,5,-5,6)\nx\n\n[1]  1  2 -2  4  5 -5  6\n\n\n\nx[1:3]\n\n[1]  1  2 -2\n\n\n\nx[c(1,2,3)]\n\n[1]  1  2 -2\n\n\n#\n# 예제4 – 2,5,6 번째의 원소를 뽑고싶다면?\n\nx&lt;-c(1,2,-2,4,5,-5,6)\nx\n\n[1]  1  2 -2  4  5 -5  6\n\n\n\nx[c(2,5,6)]\n\n[1]  2  5 -5\n\n\n#\n# 예제5 – 3번째 원소를 제외하고 호출\n\nx&lt;-c(1,2,-2,4,5,-5,6)\nx\n\n[1]  1  2 -2  4  5 -5  6\n\n\n\nx[c(1,2,4,5,6,7)]\n\n[1]  1  2  4  5 -5  6\n\n\n\nx[-3]\n\n[1]  1  2  4  5 -5  6\n\n\n# 예제6 – 3,4번째의 원소를 제외하고 호출\n\nx[c(-3,-4)]\n\n[1]  1  2  5 -5  6\n\n\n\nx[-(3:4)]\n\n[1]  1  2  5 -5  6\n\n\n\n\nB. 조건으로 뽑는 방법\n\n어떠한 조건을 주고, 그 조건에 만족하는 원소 (혹은 만족하지 않는 원소)를 뽑는 방식\n\n# 예제1 – 양수의 원소를 뽑는다.\n\nx&lt;-c(1,2,-2,4,5,-5,6)\nx\n\n[1]  1  2 -2  4  5 -5  6\n\n\n\nx&gt;0\n\n[1]  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE\n\n\n\nx[x&gt;0]\n\n[1] 1 2 4 5 6\n\n\n#\n# 예제2 – 3보다 큰 원소를 뽑는 방법\n\nx&lt;-c(1,2,-2,4,5,-5,6)\nx\n\n[1]  1  2 -2  4  5 -5  6\n\n\n\nx[x&gt;3]\n\n[1] 4 5 6\n\n\n#\n# 예제3 – 3번째 원소를 뽑는방법\n\nx&lt;-c(1,2,-2,4,5,-5,6)\nx\n\n[1]  1  2 -2  4  5 -5  6\n\n\n\narr = c(FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE)\narr\n\n[1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n\n\n\nx[arr]\n\n[1] -2\n\n\n#\n# 예제4 – 값이 -2인 원소를 뽑아라.\n\nx&lt;-c(1,2,-2,4,5,-5,6)\nx\n\n[1]  1  2 -2  4  5 -5  6\n\n\n\nx[x == -2]\n\n[1] -2\n\n\n#\n# 예제5 – 값이 -1.5와 가장 가까운 원소를 뽑아라.\n\nx - (-1.5)\n\n[1]  2.5  3.5 -0.5  5.5  6.5 -3.5  7.5\n\n\n\nabs(x - (-1.5))\n\n[1] 2.5 3.5 0.5 5.5 6.5 3.5 7.5\n\n\n\nmin(abs(x - (-1.5)))\n\n[1] 0.5\n\n\n\nabs(x - (-1.5)) == min(abs(x - (-1.5)))\n\n[1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n\n\n\nx[abs(x - (-1.5)) == min(abs(x - (-1.5)))]\n\n[1] -2\n\n\n#\n# 예제6 – 값이 0.5와 가장 가까운 원소를 뽑아라.\n\nx = rnorm(100)\nx\n\n  [1] -0.311304729  0.196110860 -0.191987399  0.632793486  0.407982410\n  [6]  0.864718044 -0.352966617 -1.406632984  0.930323376 -0.211177345\n [11]  0.174489842 -1.038388188 -1.130694552  0.162414718  0.857153460\n [16]  0.405123384  0.026784113 -1.026959835 -0.462168583 -0.375374318\n [21]  1.591985359 -0.064623494  0.478029165 -0.045583822  2.478326033\n [26]  0.331902286  0.499881633  0.119367202  0.007451714  0.725801470\n [31]  0.656933182  0.073287602 -1.415772205 -0.477024858  1.221302265\n [36] -0.398021993  0.546331883 -0.324018146  0.330657882 -0.360152774\n [41]  1.331364124 -0.672527606 -0.437897514  1.105811374 -0.232983468\n [46]  0.793021899 -0.618798438 -0.654156632  1.826482099 -0.409432487\n [51]  1.081860665  0.657260779  0.338851369  0.051188750  0.133293222\n [56] -2.143363730 -0.932413327  1.259017917  0.560828441  0.549731458\n [61]  0.374222028  1.212201517 -0.766937380  0.738233964 -0.213323397\n [66]  0.449868009  0.834543548  1.008085221 -1.548439118 -0.162223345\n [71] -0.294176392 -2.081089322  0.744885524  0.859101047  0.325550519\n [76] -0.504631524 -0.053201153 -2.081642005  0.063341785 -0.032805806\n [81]  0.890016964 -2.011684049  0.615605307  0.611636798 -1.394488649\n [86] -0.665951804 -0.638994227  1.245491526  1.603119132 -1.859557340\n [91] -1.349329167 -0.168900117  1.378241904 -0.663119091  0.016505925\n [96] -0.808047477 -0.008849918 -1.174490950 -0.385805036  0.008856681\n\n\n\nx[abs(x - 0.5) == min(abs(x - 0.5))]\n\n[1] 0.4998816\n\n\n#"
  },
  {
    "objectID": "content/02wk-1.html#조건문과-반복문",
    "href": "content/02wk-1.html#조건문과-반복문",
    "title": "02wk-1: [R] – 문제풀이, Bool 자료형과 조건판단, 벡터인덱싱, 조건문과 반복문 // 숙제",
    "section": "4. 조건문과 반복문",
    "text": "4. 조건문과 반복문\n\nA. 조건문\n- 예시1\n\nx = -3\nif(x&gt;0){\n    print(\"양수\")\n}else if(x&lt;0){\n    print(\"음수\")\n}else{\n    print(\"0\")\n}\n\n[1] \"음수\"\n\n\nx = 0  \n만약, x&gt;0 이면, \n    print(\"양수\")\n그렇지않고, 만약 x&lt;0 이면,\n    print(\"음수\")\n그외의 모든 경우는\n    print(\"0\") \n\n\nB. 반복문\n- 예시1\n\nfor(x in 1:10){\n    print(x)\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n\n\n- 예시2\n\nfor(x in 1:10){\n    print(x^2)\n}\n\n[1] 1\n[1] 4\n[1] 9\n[1] 16\n[1] 25\n[1] 36\n[1] 49\n[1] 64\n[1] 81\n[1] 100\n\n\n- 예시3 – \\(1,4,9,\\dots,100\\) 에서 \\(20\\)보다 크고 \\(80\\)보다 작은 수를 출력\n\nfor(x in 1:10){\n    if( (x^2&gt;20)*(x^2&lt;80) ){\n        print(x^2)\n    }\n}\n\n[1] 25\n[1] 36\n[1] 49\n[1] 64"
  },
  {
    "objectID": "content/02wk-1.html#숙제",
    "href": "content/02wk-1.html#숙제",
    "title": "02wk-1: [R] – 문제풀이, Bool 자료형과 조건판단, 벡터인덱싱, 조건문과 반복문 // 숙제",
    "section": "5. 숙제",
    "text": "5. 숙제\n1. 아래와 같은 벡터 x 를 선언하였다고 하자.\n\nset.seed(43053)\nx = rnorm(10)\nx\n\n [1]  0.4553673 -0.7687380  1.1783003  0.4023584 -0.4353551  0.1719379\n [7]  0.7200204 -2.3899837  1.6949456 -0.3216081\n\n\n값이 -0.1 보다 크고 0.5 보다 작은 원소들의 합을 구하여라.\n2. for를 이용하여 1부터 100까지 더하는 코드를 작성하여라."
  },
  {
    "objectID": "content/01wk-2.html#문제풀이",
    "href": "content/01wk-2.html#문제풀이",
    "title": "01wk-2: [R] – 문제풀이, 변수 이름 선언, 벡터의 선언, 함수의 선언",
    "section": "1. 문제풀이",
    "text": "1. 문제풀이\n2025수능-6. \\(\\cos \\left(\\frac{\\pi}{2} + \\theta \\right) = -\\frac{1}{5}\\) 일 때, \\(\\frac{\\sin\\theta}{1 - \\cos^2\\theta}\\) 의 값은? [3점]\n\n\\(-5\\)\n\n\\(-\\sqrt{5}\\)\n\n\\(0\\)\n\\(\\sqrt{5}\\)\n\\(5\\)\n\n(풀이1)\n\ntheta = 2.94\n\n\ncos(pi/2+theta) # 이 값이 -0.2 정도가 되어야 할텐데?\n\n[1] -0.20023\n\n\n반복계산을 하다보니까 \\(\\theta \\approx 2.94\\) 인듯\n\nsin(theta)/(1-cos(theta)^2)\n\n[1] 4.994257\n\n\n(풀이2)\n\nacos(-1/5) - pi/2\n\n[1] 0.2013579\n\n\n\nsin(0.2013579)/(1-cos(0.2013579)^2)\n\n[1] 5.000001\n\n\n\ninput = -0.2\ntheta = acos(input) - pi/2\noutput = sin(theta) / (1-cos(theta)^2)\noutput\n\n[1] 5\n\n\n이걸 하나로 묶으면..\n\nsolve &lt;- function(input){\n    theta = acos(input) - pi/2\n    output = sin(theta)/(1-cos(theta)^2)\n    return(output)\n}\n\n\nsolve(-0.2)\n\n[1] 5\n\n\n(풀이3) – 미완성의 풀이\n\n# theta = c(0.0, 0.1, 0.2, 0,3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9,\n#           1.0, 1.1, 1.2, 1,3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9,\n#           2.0, 2.1, 2.2, 2,3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9)\ntheta = 0:300/100\ntheta\n\n  [1] 0.00 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.11 0.12 0.13 0.14\n [16] 0.15 0.16 0.17 0.18 0.19 0.20 0.21 0.22 0.23 0.24 0.25 0.26 0.27 0.28 0.29\n [31] 0.30 0.31 0.32 0.33 0.34 0.35 0.36 0.37 0.38 0.39 0.40 0.41 0.42 0.43 0.44\n [46] 0.45 0.46 0.47 0.48 0.49 0.50 0.51 0.52 0.53 0.54 0.55 0.56 0.57 0.58 0.59\n [61] 0.60 0.61 0.62 0.63 0.64 0.65 0.66 0.67 0.68 0.69 0.70 0.71 0.72 0.73 0.74\n [76] 0.75 0.76 0.77 0.78 0.79 0.80 0.81 0.82 0.83 0.84 0.85 0.86 0.87 0.88 0.89\n [91] 0.90 0.91 0.92 0.93 0.94 0.95 0.96 0.97 0.98 0.99 1.00 1.01 1.02 1.03 1.04\n[106] 1.05 1.06 1.07 1.08 1.09 1.10 1.11 1.12 1.13 1.14 1.15 1.16 1.17 1.18 1.19\n[121] 1.20 1.21 1.22 1.23 1.24 1.25 1.26 1.27 1.28 1.29 1.30 1.31 1.32 1.33 1.34\n[136] 1.35 1.36 1.37 1.38 1.39 1.40 1.41 1.42 1.43 1.44 1.45 1.46 1.47 1.48 1.49\n[151] 1.50 1.51 1.52 1.53 1.54 1.55 1.56 1.57 1.58 1.59 1.60 1.61 1.62 1.63 1.64\n[166] 1.65 1.66 1.67 1.68 1.69 1.70 1.71 1.72 1.73 1.74 1.75 1.76 1.77 1.78 1.79\n[181] 1.80 1.81 1.82 1.83 1.84 1.85 1.86 1.87 1.88 1.89 1.90 1.91 1.92 1.93 1.94\n[196] 1.95 1.96 1.97 1.98 1.99 2.00 2.01 2.02 2.03 2.04 2.05 2.06 2.07 2.08 2.09\n[211] 2.10 2.11 2.12 2.13 2.14 2.15 2.16 2.17 2.18 2.19 2.20 2.21 2.22 2.23 2.24\n[226] 2.25 2.26 2.27 2.28 2.29 2.30 2.31 2.32 2.33 2.34 2.35 2.36 2.37 2.38 2.39\n[241] 2.40 2.41 2.42 2.43 2.44 2.45 2.46 2.47 2.48 2.49 2.50 2.51 2.52 2.53 2.54\n[256] 2.55 2.56 2.57 2.58 2.59 2.60 2.61 2.62 2.63 2.64 2.65 2.66 2.67 2.68 2.69\n[271] 2.70 2.71 2.72 2.73 2.74 2.75 2.76 2.77 2.78 2.79 2.80 2.81 2.82 2.83 2.84\n[286] 2.85 2.86 2.87 2.88 2.89 2.90 2.91 2.92 2.93 2.94 2.95 2.96 2.97 2.98 2.99\n[301] 3.00\n\n\n\nplot(theta,cos(pi/2+theta))\nabline(h=-0.2,col=2)\n\n\n\n\n\n\n\n\n#"
  },
  {
    "objectID": "content/01wk-2.html#변수-이름-선언",
    "href": "content/01wk-2.html#변수-이름-선언",
    "title": "01wk-2: [R] – 문제풀이, 변수 이름 선언, 벡터의 선언, 함수의 선언",
    "section": "2. 변수 이름 선언",
    "text": "2. 변수 이름 선언\n\nA. 변수이름에 어떠한 값을 넣는 방법\n- 방법1\n\nd = 1\n\n- 방법2\n\ne &lt;- 3\n\n\n\nB. 잘못된 변수명\n# 예제1 – 특수문자 불가능\n\na! &lt;- 3\n\nError: Error in Unknown source: &lt;text&gt;:1:2: unexpected '!'\n1: a!\n     ^\n\n\n#\n# 예제2 – 숫자로 시작하는 변수이름 불가능\n\n2a &lt;- 3 \n\nError: Error in Unknown source: &lt;text&gt;:1:2: unexpected symbol\n1: 2a\n     ^\n\n\n\na2 &lt;- 3 \n\n\n이것은 가능 (숫자로 시작되면 안되는 것이지 숫자를 포함하지 말라는 의미는 아님)\n\n#\n# 예제3 – 띄어쓰기 불가능\n\nGuebin Choi &lt;- 33 \n\nError: Error in Unknown source: &lt;text&gt;:1:8: unexpected symbol\n1: Guebin Choi\n           ^\n\n\n\nthis_is_333 &lt;- 333\n\n\n띄어쓰기 대신 언더바(_)를 활용한다.\n\n\nthis.is.777 &lt;- 777 \n\n\n언더바 말고 닷(.)을 선호하는 사람도 있다.\n\n#\n# 예제4 – 언더바를 포함하는 것은 가능하지만, 언더바로 시작하는 변수명은 사용할 수 없다. `\n\n_x &lt;- 33\n\nError: Error in Unknown source: &lt;text&gt;:1:2: unexpected symbol\n1: _x\n     ^\n\n\n#\n# 예제5 – 사용할 수는 있지만 권장하지 않는 변수이름\n\npi\n\n[1] 3.141593\n\n\n\npi&lt;-333\n\n\npi\n\n[1] 333"
  },
  {
    "objectID": "content/01wk-2.html#벡터의-선언",
    "href": "content/01wk-2.html#벡터의-선언",
    "title": "01wk-2: [R] – 문제풀이, 변수 이름 선언, 벡터의 선언, 함수의 선언",
    "section": "3. 벡터의 선언",
    "text": "3. 벡터의 선언\n# 예제1 – 직접 입력\n\nc(1,2,3,3,4,5,2)\n\n[1] 1 2 3 3 4 5 2\n\n\n# 예제2 – seq를 이용\n\nseq(from=0,to=10,by=0.1) # 0~10 까지 0.1의 간격으로 수열만들기 \n\n  [1]  0.0  0.1  0.2  0.3  0.4  0.5  0.6  0.7  0.8  0.9  1.0  1.1  1.2  1.3  1.4\n [16]  1.5  1.6  1.7  1.8  1.9  2.0  2.1  2.2  2.3  2.4  2.5  2.6  2.7  2.8  2.9\n [31]  3.0  3.1  3.2  3.3  3.4  3.5  3.6  3.7  3.8  3.9  4.0  4.1  4.2  4.3  4.4\n [46]  4.5  4.6  4.7  4.8  4.9  5.0  5.1  5.2  5.3  5.4  5.5  5.6  5.7  5.8  5.9\n [61]  6.0  6.1  6.2  6.3  6.4  6.5  6.6  6.7  6.8  6.9  7.0  7.1  7.2  7.3  7.4\n [76]  7.5  7.6  7.7  7.8  7.9  8.0  8.1  8.2  8.3  8.4  8.5  8.6  8.7  8.8  8.9\n [91]  9.0  9.1  9.2  9.3  9.4  9.5  9.6  9.7  9.8  9.9 10.0\n\n\n\nseq(from=0, to=1, length.out = 27) # 0~1 까지 등간격으로 총 27개의 수열만들기 \n\n [1] 0.00000000 0.03846154 0.07692308 0.11538462 0.15384615 0.19230769\n [7] 0.23076923 0.26923077 0.30769231 0.34615385 0.38461538 0.42307692\n[13] 0.46153846 0.50000000 0.53846154 0.57692308 0.61538462 0.65384615\n[19] 0.69230769 0.73076923 0.76923077 0.80769231 0.84615385 0.88461538\n[25] 0.92307692 0.96153846 1.00000000\n\n\n# 예제3 – : 를 이용\n\n1:22\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22\n\n\n이 방법을 살짝 응용하면 0~1까지 57개의 변수를 넣는 방법을 아래와 같이 할 수 있다.\n\n0:56/56\n\n [1] 0.00000000 0.01785714 0.03571429 0.05357143 0.07142857 0.08928571\n [7] 0.10714286 0.12500000 0.14285714 0.16071429 0.17857143 0.19642857\n[13] 0.21428571 0.23214286 0.25000000 0.26785714 0.28571429 0.30357143\n[19] 0.32142857 0.33928571 0.35714286 0.37500000 0.39285714 0.41071429\n[25] 0.42857143 0.44642857 0.46428571 0.48214286 0.50000000 0.51785714\n[31] 0.53571429 0.55357143 0.57142857 0.58928571 0.60714286 0.62500000\n[37] 0.64285714 0.66071429 0.67857143 0.69642857 0.71428571 0.73214286\n[43] 0.75000000 0.76785714 0.78571429 0.80357143 0.82142857 0.83928571\n[49] 0.85714286 0.87500000 0.89285714 0.91071429 0.92857143 0.94642857\n[55] 0.96428571 0.98214286 1.00000000\n\n\n물론 아래와 같이하는것이 더 가독성이 좋다.\n\nseq(from=0,to=1,length.out =57)\n\n [1] 0.00000000 0.01785714 0.03571429 0.05357143 0.07142857 0.08928571\n [7] 0.10714286 0.12500000 0.14285714 0.16071429 0.17857143 0.19642857\n[13] 0.21428571 0.23214286 0.25000000 0.26785714 0.28571429 0.30357143\n[19] 0.32142857 0.33928571 0.35714286 0.37500000 0.39285714 0.41071429\n[25] 0.42857143 0.44642857 0.46428571 0.48214286 0.50000000 0.51785714\n[31] 0.53571429 0.55357143 0.57142857 0.58928571 0.60714286 0.62500000\n[37] 0.64285714 0.66071429 0.67857143 0.69642857 0.71428571 0.73214286\n[43] 0.75000000 0.76785714 0.78571429 0.80357143 0.82142857 0.83928571\n[49] 0.85714286 0.87500000 0.89285714 0.91071429 0.92857143 0.94642857\n[55] 0.96428571 0.98214286 1.00000000\n\n\n#\n# 예제4 – rep 를 이용\n\nrep(0,5)\n\n[1] 0 0 0 0 0\n\n\n#"
  },
  {
    "objectID": "content/01wk-2.html#함수의-선언",
    "href": "content/01wk-2.html#함수의-선언",
    "title": "01wk-2: [R] – 문제풀이, 변수 이름 선언, 벡터의 선언, 함수의 선언",
    "section": "4. 함수의 선언",
    "text": "4. 함수의 선언\n- 함수의 기본 구조\n함수이름 &lt;- function(입력){\n    함수의 기능 \n    return(출력)\n    }\n\nsolve &lt;- function(input){\n    theta = acos(input) - pi/2\n    output = sin(theta)/(1-cos(theta)^2)\n    return(output)\n}\n\n\nsolve(-1/5)\n\n[1] 5\n\n\n- 아래의 2개의 코드는 거의 같다.\n\n### 1 \nsolve &lt;- function(input){\n    theta = acos(input) - pi/2\n    output = sin(theta)/(1-cos(theta)^2)\n    return(output)\n}\nsolve(-1/5)\n\n### 2\ninput = -1/5 \ntheta = acos(input) - pi/2\noutput = sin(theta)/(1-cos(theta)^2)\noutput\n\n[1] 5\n\n\n- return을 생략해도 괜찮다.\n\nsolve &lt;- function(input){\n    theta = acos(input) - pi/2\n    output = sin(theta)/(1-cos(theta)^2)\n    return(output)\n}\nsolve(-1/5)\n\n[1] 5\n\n\n\nsolve &lt;- function(input){\n    theta = acos(input) - pi/2\n    output = sin(theta)/(1-cos(theta)^2)\n    output\n}\nsolve(-1/5)\n\n[1] 5\n\n\n\nsolve &lt;- function(input){\n    theta = acos(input) - pi/2\n    sin(theta)/(1-cos(theta)^2)\n}\nsolve(-1/5)\n\n[1] 5"
  },
  {
    "objectID": "content/04wk-2.html#벡터와-행렬의-결합",
    "href": "content/04wk-2.html#벡터와-행렬의-결합",
    "title": "04wk-2: 벡터와 행렬의 결합, 벡터관련 연산, 자료의 변환 // 숙제",
    "section": "1. 벡터와 행렬의 결합",
    "text": "1. 벡터와 행렬의 결합\n# 예제1\n\nx &lt;- c(1,2,3)\ny &lt;- c(1,2,3,4)\n\n\nc(x,y)\n\n[1] 1 2 3 1 2 3 4\n\n\n\nc(y,x)\n\n[1] 1 2 3 4 1 2 3\n\n\n\nc(-1,x)\n\n[1] -1  1  2  3\n\n\n\nc(x,2,2,2,y)\n\n [1] 1 2 3 2 2 2 1 2 3 4\n\n\n\nc는 사실 결합하라라는 의미를 가짐\n\n#\n# 예제2 – 차원이 맞지 않을 경우\n\nx&lt;-c(1,2,3,4)\ny&lt;-c(1,2)\ncbind(x,y)\n\n     x y\n[1,] 1 1\n[2,] 2 2\n[3,] 3 1\n[4,] 4 2\n\n\n\nx&lt;-c(1,2,3,4)\ncbind(1,x)\n\n       x\n[1,] 1 1\n[2,] 1 2\n[3,] 1 3\n[4,] 1 4\n\n\n\nx&lt;-c(1,2,3,4)\ny&lt;-c(1,2)\nrbind(x,y)\n\n  [,1] [,2] [,3] [,4]\nx    1    2    3    4\ny    1    2    1    2\n\n\n#\n# 예제3\n\nx&lt;-c(1,2,3)\ny&lt;-c(4,5)\n\n\ncbind(1,c(x,y))\n\n     [,1] [,2]\n[1,]    1    1\n[2,]    1    2\n[3,]    1    3\n[4,]    1    4\n[5,]    1    5\n\n\n#\n# 예제4\n\nX&lt;-rbind(1:5,6:10)\ny&lt;-c(1,2)\n\n\ncbind(X,y,y,X)\n\n                y y           \n[1,] 1 2 3 4  5 1 1 1 2 3 4  5\n[2,] 6 7 8 9 10 2 2 6 7 8 9 10\n\n\n* 이름을 지우기 위해서는 아래와 같이 하면 된다.\n\nmat = cbind(X,y,y,X)\ncolnames(mat)= NULL \nmat\n\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]\n[1,]    1    2    3    4    5    1    1    1    2     3     4     5\n[2,]    6    7    8    9   10    2    2    6    7     8     9    10\n\n\n#\n# 예제5\n\nX&lt;-rbind(1:5,6:10)\nrbind(X,1)\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    6    7    8    9   10\n[3,]    1    1    1    1    1\n\n\n#\n# 예제6\n\nX &lt;- rbind(1:5,6:10,1:5)\nY &lt;- cbind(1:3,4:6,7:9)\n\n\ncbind(X,Y)\n\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]\n[1,]    1    2    3    4    5    1    4    7\n[2,]    6    7    8    9   10    2    5    8\n[3,]    1    2    3    4    5    3    6    9\n\n\n\nrbind(X,Y)\n\nError: Error in rbind(X, Y): number of columns of matrices must match (see arg 2)\n\n\n#"
  },
  {
    "objectID": "content/04wk-2.html#벡터관련-연산",
    "href": "content/04wk-2.html#벡터관련-연산",
    "title": "04wk-2: 벡터와 행렬의 결합, 벡터관련 연산, 자료의 변환 // 숙제",
    "section": "2. 벡터관련 연산",
    "text": "2. 벡터관련 연산\n# 예제1\n\nc(1,2,6) %in% c(1,2,3,4)\n\n[1]  TRUE  TRUE FALSE\n\n\n#\n# 예제2\n\nunion(c(1,1,2,2),c(2,3,4))\n\n[1] 1 2 3 4\n\n\n#\n# 예제3\n\nintersect(1:5,2:6)\n\n[1] 2 3 4 5\n\n\n#"
  },
  {
    "objectID": "content/04wk-2.html#자료의변환",
    "href": "content/04wk-2.html#자료의변환",
    "title": "04wk-2: 벡터와 행렬의 결합, 벡터관련 연산, 자료의 변환 // 숙제",
    "section": "3. 자료의변환",
    "text": "3. 자료의변환\n# motivating ex – 20부터 30까지의 정수중 홀수를 출력하라\n\nx = 20:30\nx\n\n [1] 20 21 22 23 24 25 26 27 28 29 30\n\n\n\nx %% 2\n\n [1] 0 1 0 1 0 1 0 1 0 1 0\n\n\n\nas.logical(x %% 2)\n\n [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE\n\n\n\nx[as.logical(x %% 2)]\n\n[1] 21 23 25 27 29\n\n\n#\n# 예제1\n\nx = \"123\"\nx\n\n[1] \"123\"\n\n\n\nas.numeric(x) # as.double(x) 와 동일\n\n[1] 123\n\n\n\nas.logical(x)\n\n[1] NA\n\n\n#\n# 예제2\n\nx = \"1.23\"\n\n\nas.numeric(x) # as.double(x) 와 동일\n\n[1] 1.23\n\n\n\nas.logical(x)\n\n[1] NA\n\n\n#\n# 예제3\n\nx = 3.14\n\n\nas.character(x)\n\n[1] \"3.14\"\n\n\n\nas.logical(x)\n\n[1] TRUE\n\n\n#\n# 예제4\n\nx = 0\n\n\nas.character(x)\n\n[1] \"0\"\n\n\n\nas.logical(x)\n\n[1] FALSE\n\n\n#\n# 예제5\n\nx = -5:5\nx\n\n [1] -5 -4 -3 -2 -1  0  1  2  3  4  5\n\n\n\nas.character(x)\n\n [1] \"-5\" \"-4\" \"-3\" \"-2\" \"-1\" \"0\"  \"1\"  \"2\"  \"3\"  \"4\"  \"5\" \n\n\n\nas.logical(x)\n\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n\n\n#\n# 예제6\n\nx = -1:1\nx\n\n[1] -1  0  1\n\n\n\nas.matrix(x)\n\n     [,1]\n[1,]   -1\n[2,]    0\n[3,]    1\n\n\n#\n# 예제7\n\nx = cbind(-1:1)\nx\n\n     [,1]\n[1,]   -1\n[2,]    0\n[3,]    1\n\n\n\nas.vector(x)\n\n[1] -1  0  1\n\n\n#\n# 예제8\n\nx = rbind(-1:1)\nx\n\n     [,1] [,2] [,3]\n[1,]   -1    0    1\n\n\n\nas.vector(x)\n\n[1] -1  0  1\n\n\n#\n# 예제9\n\nx = cbind(c(1,2),c(3,4))\nx\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n\n\nas.vector(x)\n\n[1] 1 2 3 4\n\n\n#\n# 예제10\n\nx = c(1,2,4,3)\nx\n\n[1] 1 2 4 3\n\n\n\nas.logical(as.matrix(x))\n\n[1] TRUE TRUE TRUE TRUE\n\n\n\nas.matrix(as.logical(x))\n\n     [,1]\n[1,] TRUE\n[2,] TRUE\n[3,] TRUE\n[4,] TRUE\n\n\n#"
  },
  {
    "objectID": "content/04wk-2.html#숙제",
    "href": "content/04wk-2.html#숙제",
    "title": "04wk-2: 벡터와 행렬의 결합, 벡터관련 연산, 자료의 변환 // 숙제",
    "section": "4. 숙제",
    "text": "4. 숙제\n1. 아래와 같은 벡터가 있다고 하자.\n\nx &lt;- -5:0 \ny &lt;- 1:5 \n\n두 벡터를 이용하여 아래와 같은 벡터를 만들라.\n\n# 출력예시 \n\n [1] -5 -4 -3 -2 -1  0  1  2  3  4  5\n\n\n(풀이)\n\nc(x,y)\n\n [1] -5 -4 -3 -2 -1  0  1  2  3  4  5\n\n\n2. 아래와 같은 벡터가 있다고 하자.\n\nx &lt;- c(1,0,1,1,0)\nx\n\n[1] 1 0 1 1 0\n\n\n1을 TRUE로 0을 FALSE로 바꾸라. 즉 아래의 결과를 얻어라.\n\n# 출력예시\n\n[1]  TRUE FALSE  TRUE  TRUE FALSE\n\n\n(풀이)\n\nas.logical(x)\n\n[1]  TRUE FALSE  TRUE  TRUE FALSE"
  }
]